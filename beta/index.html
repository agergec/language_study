<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover"/>
  <title data-i18n="page_title">ğŸ‡«ğŸ‡· French Listening Study</title>

  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ‡«ğŸ‡·</text></svg>">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&display=swap" rel="stylesheet">

  <style>
    /* --- CSS Reset & Variables --- */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      --primary-color: #4A90E2;
      --success-color: #50E3C2;
      --warning-color: #F5A623;
      --secondary-color: #B8E986;
      --text-color: #4A4A4A;
      --light-gray: #F7F7F7;
      --border-color: #EAEAEA;
      --background-color: #FFFFFF;
      --font-family: 'Nunito', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      --border-radius: 12px;
      --shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    }

    /* --- Base Layout (Viewport App) --- */
    html, body {
      height: 100vh;
      width: 100vw;
      overflow: hidden;
      font-family: var(--font-family);
      background-color: var(--light-gray);
      color: var(--text-color);
    }

    .container {
      width: 100%;
      height: 100%;
      min-height: 100svh;
      display: grid;
      grid-template-rows: auto auto 1fr auto auto;
      grid-template-columns: 1fr;
      grid-template-areas: "header" "sub-header" "display" "controls" "footer";
      padding: 0.75rem;
      gap: 0.75rem;
    }

    /* --- Desktop Layout --- */
    @media (min-width: 1024px) and (min-height: 600px) {
      .container {
        grid-template-rows: auto auto 1fr auto;
        grid-template-columns: 280px 1fr 200px;
        grid-template-areas: "header header header" "sub-header sub-header sub-header" "history display controls" "footer footer footer";
        padding: 1.5rem;
        gap: 1.5rem;
      }
      .container.history-hidden { grid-template-columns: 40px 1fr 200px; }
    }

    /* --- Header, Sub-header & Progress Bar --- */
    .header { grid-area: header; display: flex; flex-direction: column; gap: 0.75rem; }
    .header-top { display: flex; justify-content: space-between; align-items: center; }
    .header h1 { font-size: 1.25em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .header-actions { display: flex; align-items: center; gap: 1rem; flex-shrink: 0; }
    .icon-btn { background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--text-color); transition: transform 0.2s; }
    .icon-btn:hover { transform: scale(1.1); }
    .language-flags { display: flex; gap: 0.5rem; }
    .language-flag { font-size: 1.5rem; cursor: pointer; opacity: 0.5; transition: all 0.2s ease; background: none; border: none; padding: 0; line-height: 1; }
    .language-flag.active { opacity: 1; transform: scale(1.15); }
    /* Mobile: use hamburger; hide individual header icons/flags only */
    @media (max-width: 1023px) {
      .header-actions .icon-btn:not(#menuBtn), .header-actions .language-flags { display: none; }
    }
    
    .progress-bar { width: 100%; height: 5px; background-color: var(--border-color); border-radius: 5px; overflow: hidden; }
    .progress-bar-fill { height: 100%; width: 0%; background-color: var(--success-color); transition: width 0.3s ease-in-out; border-radius: 5px; }

    /* Hide old top status strip; we move indicators to footer */
    .sub-header { display: none; }
    .status-indicator { background-color: var(--light-gray); padding: 0.25rem 0.75rem; border-radius: 1rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100%; }

    /* --- Main Display --- */
    .display-container { grid-area: display; background: var(--primary-color); color: white; border-radius: var(--border-radius); display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1rem; position: relative; overflow: hidden; box-shadow: var(--shadow); }
    .display-area-upper { font-size: clamp(2rem, 8vw, 4.5rem); font-weight: 800; text-align: center; }
    .display-instruction { margin-top: 0.5rem; font-size: clamp(0.9rem, 2.5vw, 1rem); opacity: 0.9; text-align: center; }
    .session-complete-message { font-size: clamp(1.5rem, 5vw, 2.5rem); opacity: 0.9; }

    /* --- Controls --- */
    .controls-vertical { grid-area: controls; display: flex; flex-direction: column; gap: 0.75rem; }
    @media (max-width: 1023px) { .controls-vertical { flex-direction: row; flex-wrap: wrap; } }
    .btn { padding: 0.75rem 1rem; border: none; border-radius: 8px; cursor: pointer; font-size: 1rem; font-weight: 700; transition: all .2s ease; color: white; text-align: center; }
    @media (max-width: 1023px) { .btn { flex-grow: 1; min-width: 120px; } }
    .btn:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15); }
    .btn:disabled { background-color: #ccc; cursor: not-allowed; transform: none; box-shadow: none; }
    .btn-primary { background-color: var(--primary-color); }
    .btn-secondary { background-color: var(--secondary-color); color: var(--text-color); }
    /* Ensure Repeat button matches other buttons' text color */
    #repeatBtn { color: #fff; }
    .btn-success { background-color: var(--success-color); }
    .btn-warning { background-color: var(--warning-color); }
    .btn-info { background-color: #90b8de; }

    /* --- History Sidebar --- */
    .history-sidebar { grid-area: history; display: none; flex-direction: column; background: var(--background-color); border-radius: var(--border-radius); box-shadow: var(--shadow); padding: 1rem; overflow: hidden; transition: all 0.3s ease-in-out; }
    @media (min-width: 1024px) and (min-height: 600px) { .history-sidebar { display: flex; } }
    .history-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; flex-shrink: 0; }
    .history-title { font-weight: bold; border-bottom: 1px solid var(--border-color); padding-bottom: 0.5rem; flex-grow: 1; }
    #historyToggleBtn { margin-left: 0.5rem; transform: rotate(0deg); transition: transform 0.3s; }
    .history-list { flex-grow: 1; overflow-y: auto; padding-right: 0.5rem; }
    .history-item { padding: 0.25rem 0.5rem; border-radius: 4px; }
    .history-item:nth-child(even) { background-color: var(--light-gray); }

    .container.history-hidden .history-sidebar { padding: 1rem 0; }
    .container.history-hidden .history-title,
    .container.history-hidden .history-list { display: none; }
    .container.history-hidden #historyToggleBtn { transform: rotate(180deg); }

    /* --- Countdown --- */
    .countdown-wrapper { position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%); display: none; flex-direction: column; align-items: center; justify-content: center; min-height: 60px; pointer-events: none; top: auto; }
    .progress-ring { position: relative; width: 60px; height: 60px; }
    .progress-ring__circle { transition: stroke-dashoffset 0.1s linear; transform: rotate(-90deg); transform-origin: 50% 50%; stroke-width: 6; stroke: var(--success-color); stroke-linecap: round; }
    .progress-ring__track { stroke-width: 6; stroke: var(--border-color); }
    .countdown-text { font-size: 1.5rem; font-weight: 700; color: var(--primary-color); }

    /* --- Footer / Status Bar --- */
    .footer { grid-area: footer; display: flex; flex-direction: column; gap: 0.35rem; padding-top: 0.5rem; border-top: 1px solid var(--border-color); font-size: 0.85em; }
    .footer-meta { display: flex; justify-content: space-between; align-items: center; gap: 1rem; }
    #statusInfo { display: none; }
    .bottom-status { display: flex; align-items: center; justify-content: space-between; color: #666; }
    .bottom-left { display: flex; align-items: center; gap: 0.75rem; }
    .bottom-status .sep { opacity: 0.4; }
    .bottom-status .off { opacity: 0.3; filter: grayscale(1); }
    .bottom-status span { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .bottom-version { display: none; color: #666; }
    @media (min-width: 1024px) { .bottom-version { display: inline; } }
    /* no spacer row; display grows naturally */
    .status-ok { color: #2e7d32; }
    .status-alert { color: #c62828; }

    /* --- Modals --- */
    .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(40, 40, 40, 0.55); align-items: center; justify-content: center; backdrop-filter: blur(8px); overflow-y: auto; -webkit-overflow-scrolling: touch; }
    .modal.visible { display: flex; }
    .modal-content { background-color: var(--background-color); padding: 1.5rem; border-radius: var(--border-radius); width: 90%; max-width: 500px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); max-height: 80vh; overflow-y: auto; }
    html.is-ios .modal { align-items: flex-start; padding: 1rem; }
    html.is-ios .modal-content { max-height: calc(100svh - 2rem); -webkit-overflow-scrolling: touch; }
    .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; border-bottom: 1px solid var(--border-color); padding-bottom: 0.5rem; }
    .modal-header h2 { margin: 0; }
    .modal-section { margin-bottom: 1rem; border-bottom: 1px solid var(--border-color); padding-bottom: 1rem; }
    .modal-section:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0;}
    .modal-section label { font-weight: 600; display: block; margin-bottom: 0.5rem; }
    .mode-options, .word-lists-options { display: flex; flex-direction: column; gap: 0.75rem; }
    .mode-option { display: flex; align-items: center; gap: 0.5rem; }
    .close-btn { font-size: 1.5rem; }
    #welcomeModal .modal-content { text-align: center; }
    #welcomeUploadArea { padding: 2rem; border: 3px dashed var(--primary-color); border-radius: var(--border-radius); cursor: pointer; background-color: var(--light-gray); }
    #welcomeUploadArea:hover { background-color: #eaf2fa; }
    
    .word-list { max-height: 60vh; overflow-y: auto; }

    /* --- Toast Notification --- */
    .toast {
      position: fixed;
      bottom: -100px;
      left: 50%;
      transform: translateX(-50%);
      padding: 1rem 1.5rem;
      background-color: var(--text-color);
      color: white;
      border-radius: var(--border-radius);
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      transition: bottom 0.5s ease-in-out;
      z-index: 2000;
      font-weight: 600;
    }
    .toast.visible {
      bottom: 20px;
    }
    /* iOS Safari adjustments: allow scroll and safe-area padding only on iOS */
    html.is-ios, body.is-ios {
      height: auto;
      min-height: 100svh;
      width: 100%;
      overflow-x: hidden;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }
    body.is-ios .container {
      height: auto;
      min-height: 100svh;
      padding-top: calc(0.75rem + env(safe-area-inset-top));
      padding-bottom: calc(0.75rem + env(safe-area-inset-bottom));
    }
    /* App version tags */
    .app-version-corner { display: none; }

    /* iOS adjustments: (countdown circle removed) restore default padding */
    html.is-ios .display-container { padding-bottom: 1rem; }
    html.is-ios .countdown-wrapper { bottom: calc(12px + env(safe-area-inset-bottom)); }

    /* Mobile Menu (drawer from right) */
    /* Menu shell turns right-drawer into left-rail + expanding panel */
    #menuModal .modal-content { width: 100vw; max-width: none; height: 100vh; margin: 0; border-radius: 0; background: transparent; box-shadow: none; border: 0; transform: none; display: block; }
    #menuModal.visible .modal-content { transform: none; }
    #menuModal .menu-shell { position: relative; height: 100%; }
    /* Panel animates from right->left to full-screen */
    #menuModal .panel { position: fixed; inset: 0; background: var(--background-color); transform-origin: right center; transform: translateX(8px) scaleX(0.07); opacity: 0; transition: transform 220ms cubic-bezier(.2,.8,.2,1), opacity 180ms ease; }
    #menuModal .panel[aria-hidden="true"] { pointer-events: none; }
    #menuModal .panel[aria-hidden="false"] { transform: translateX(0) scaleX(1); opacity: 1; }
    @media (prefers-reduced-motion: reduce) { #menuModal .panel { transition-duration: 1ms; } }
    #menuModal .panel-header { display: flex; align-items: center; justify-content: space-between; padding: 0.75rem 1rem; border-bottom: 1px solid var(--border-color); }
    #menuModal .panel-body { padding: 1rem; height: calc(100% - 56px); overflow: auto; }
    #menuModal .modal-header { display:none; }
    #menuModal .modal-section { border: none; padding-bottom: 0; margin-bottom: 0.75rem; }
    #menuModal .menu-list button { display: block; width: 100%; text-align: left; padding: 0.75rem 0; background: none; border: none; font-size: 1rem; font-weight: 700; color: var(--text-color); }
    #menuModal hr { border: 0; border-top: 1px solid var(--border-color); margin: 0.5rem 0; }
    #menuModal .menu-field { display: flex; flex-direction: column; gap: 0.35rem; padding: 0.5rem 0; }
    #menuModal .menu-field .label-row { display:flex; align-items:center; gap:.5rem; }
    #menuModal .menu-field label { font-weight: 700; font-size: 0.9rem; }
    #menuModal .switch-row { display: flex; align-items: center; gap: 0.5rem; }
    #menuModal .menu-icon { width: 1.2rem; text-align:center; opacity:.7; }
    #menuModal hr.menu-divider { border: 0; border-top: 1px solid var(--border-color); margin: 0.75rem 0; opacity: .7; }
    .version-inline {
      margin-top: 0.5rem;
      color: #666;
      font-size: 0.85em;
    }

    /* Floating close button (aligned with hamburger) */
    #menuCloseOverlay {
      position: fixed;
      z-index: 1500; /* above drawer */
      display: none;
      background: transparent;
      border: none;
      font-size: 1.75rem;
      color: var(--text-color);
      line-height: 1;
      touch-action: manipulation;
    }
    /* Prefer floating close on mobile */
    @media (max-width: 1023px) { #menuModal .modal-header .close-btn { display: none; } }

    /* Thin red countdown bar at top of main display */
    .countdown-topbar { position: absolute; top: 0; left: 0; right: 0; height: 3px; background: rgba(255,255,255,0.25); }
    .countdown-topbar-fill { height: 100%; width: 0%; background: #ff3b30; transition: width 0.1s linear; }
  </style>
</head>
<body>
  <div class="container">
    <header class="header">
      <div class="header-top">
        <h1 data-i18n="header_title">ğŸ‡«ğŸ‡· French Study</h1>
        <div class="header-actions">
          <button id="helpBtn" class="icon-btn" title="Help" data-i18n-title="title_help">?</button>
          <button id="settingsBtn" class="icon-btn" title="Settings" data-i18n-title="title_settings">âš™ï¸</button>
          <div class="language-flags">
            <button type="button" class="language-flag active" id="langEn" aria-label="English" title="English">ğŸ‡ºğŸ‡¸</button>
            <button type="button" class="language-flag" id="langFr" aria-label="FranÃ§ais" title="FranÃ§ais">ğŸ‡«ğŸ‡·</button>
          </div>
          <button id="menuBtn" class="icon-btn" aria-label="Menu" title="Menu" aria-controls="menuModal" aria-expanded="false">â˜°</button>
        </div>
      </div>
      <div class="progress-bar">
        <div id="progressBarFill" class="progress-bar-fill"></div>
      </div>
    </header>

    <div class="sub-header">
      <div id="activeVoiceDisplay" class="status-indicator"></div>
      <div id="activeStudyModeDisplay" class="status-indicator"></div>
      <div id="activeShuffleDisplay" class="status-indicator"></div>
    </div>

    <aside class="history-sidebar">
      <div class="history-header">
        <div class="history-title" data-i18n="history_title">Answers</div>
        <button id="historyToggleBtn" class="icon-btn" title="Toggle History Panel" data-i18n-title="title_toggle_history">â€¹</button>
      </div>
      <div class="history-list" id="historyList"></div>
    </aside>

    <main class="display-container">
      <div class="countdown-topbar"><div id="countdownTopbarFill" class="countdown-topbar-fill"></div></div>
      <div class="display-area-upper" id="displayAreaUpper" data-i18n="welcome_message" aria-live="polite" aria-atomic="true">Welcome!</div>
      <div id="displayInstruction" class="display-instruction"></div>
      <div class="countdown-wrapper">
        <svg class="progress-ring" viewBox="0 0 100 100">
          <circle class="progress-ring__track" cx="50" cy="50" r="45" fill="transparent" />
          <circle class="progress-ring__circle" cx="50" cy="50" r="45" fill="transparent" />
        </svg>
        <span id="countdownText" class="countdown-text">--</span>
      </div>
    </main>

    <aside class="controls-vertical">
      <button class="btn btn-primary" id="nextBtn" disabled data-i18n="btn_next">Next (Space)</button>
      <button class="btn btn-secondary" id="repeatBtn" disabled data-i18n="btn_repeat">Repeat (R)</button>
      <button class="btn btn-success" id="showBtn" disabled data-i18n="btn_show">Show (S)</button>
      <button class="btn btn-warning" id="voiceBtn" disabled data-i18n="btn_toggleVoice">Voice (V)</button>
      <button class="btn btn-info" id="viewListBtn" disabled data-i18n="btn_view_list">View List</button>
      <button class="btn btn-info" id="historyBtn" disabled data-i18n="btn_history">History</button>
      <div id="privativeControls" style="display:none; gap:0.5rem; flex-wrap:wrap;">
        <button class="btn btn-secondary" id="prefixUnBtn" type="button" data-i18n="btn_prefix_un">Prefix: un</button>
        <button class="btn btn-secondary" id="prefixUneBtn" type="button" data-i18n="btn_prefix_une">Prefix: une</button>
      </div>
    </aside>

    <!-- countdown moved into display container -->

    <footer class="footer">
      <div id="bottomStatus" class="bottom-status">
        <div class="bottom-left">
          <span id="bottomShuffle" aria-label="Shuffle" title="Shuffle">ğŸ”€</span>
          <span class="sep">|</span>
          <span id="bottomFileStatus" class="file-status-icon" aria-label="Files" title="Files">âŒ</span>
          <span class="sep">|</span>
          <span id="bottomVoice"></span>
          <span class="sep">|</span>
          <span id="bottomMode"></span>
          <span id="statusInfo" class="status-alert" data-i18n="status_load_prompt" aria-live="polite" aria-atomic="true"></span>
        </div>
        <span id="bottomVersion" class="bottom-version"></span>
      </div>
    </footer>
  </div>

  <div id="welcomeModal" class="modal">
    <div class="modal-content" role="dialog" aria-modal="true" tabindex="-1">
        <h2 data-i18n="welcome_title">Welcome to the French Study App!</h2>
        <p style="margin: 1rem 0;" data-i18n="welcome_instructions">To begin, please load one or more `.txt` files containing your words.</p>
        <div id="welcomeUploadArea">
            <h3 style="pointer-events: none;" data-i18n="welcome_drag_drop">Drag & Drop File(s) Here</h3>
            <p style="pointer-events: none; margin: 0.5rem 0;" data-i18n="welcome_or">or</p>
            <button class="btn btn-primary" id="welcomeBrowseBtn" data-i18n="welcome_browse">Browse Files</button>
            <div id="iosFilePickerRow" style="display:none; margin-top: 0.75rem;">
              <input type="file" id="iosFileInput" accept=".txt" multiple style="display:block; margin: 0 auto;" />
            </div>
        </div>
            <div id="welcomeVersion" class="version-inline"></div>
    </div>
  </div>

  <div id="settingsModal" class="modal">
    <div class="modal-content" role="dialog" aria-modal="true" tabindex="-1">
      <div class="modal-header">
        <h2 data-i18n="settings_title">Settings</h2>
        <button class="icon-btn close-btn" data-i18n-title="label_close" data-i18n-aria-label="label_close" aria-label="Close" title="Close">&times;</button>
      </div>
      <div class="modal-section">
        <p style="margin:0; color:#666;">Controls have moved to the Menu (â˜°).</p>
      </div>
      <div id="wordListsSection" class="modal-section" style="display: none;">
        <label data-i18n="label_active_word_lists">Active Word Lists</label>
        <div id="wordListsOptions" class="word-lists-options"></div>
      </div>
    </div>
  </div>

  <div id="helpModal" class="modal">
    <div class="modal-content" role="dialog" aria-modal="true" tabindex="-1">
        <div class="modal-header"><h2 data-i18n="help_title">Help</h2><button class="icon-btn close-btn" data-i18n-title="label_close" data-i18n-aria-label="label_close" aria-label="Close" title="Close">&times;</button></div>
        <div class="modal-section">
            <h4 data-i18n="help_getting_started">ğŸš€ Getting Started</h4>
            <p data-i18n="help_getting_started_body">Load a word list by dragging one or more <code>.txt</code> files onto the page, or by clicking the welcome screen to browse your files.</p>
        </div>
        <div class="modal-section">
            <h4 data-i18n="help_main_controls">ğŸ® Main Controls</h4>
            <ul>
                <li data-i18n="help_main_controls_next"><b>Next (Space):</b> Proceeds to the next word.</li>
                <li data-i18n="help_main_controls_repeat"><b>Repeat (R):</b> Repeats the audio for the current word.</li>
                <li data-i18n="help_main_controls_show"><b>Show (S):</b> Instantly reveals the text of the current word.</li>
            </ul>
        </div>
        <div class="modal-section">
            <h4 data-i18n="help_privative_title">ğŸ§© Privative Prefix Quiz</h4>
            <p data-i18n="help_privative_body">When your list has words that begin with <b>un</b> or <b>une</b>, enable the Privative Prefix mode in Settings. You will see the base word like â€œ<b>â€¦</b> amiâ€. Choose the correct prefix with the buttons. If you skip, the answer is recorded as â€œ<b>â€¦</b> amiâ€ in Answers.</p>
        </div>
        <div class="modal-section">
            <h4 data-i18n="help_settings">âš™ï¸ Settings</h4>
            <p data-i18n="help_settings_body">Click the gear icon to manage settings. You can choose from different study modes, select voices, and enable/disable your loaded word lists for the current session. Use â€œTest Voiceâ€ to preview the current voice.</p>
        </div>
        <div class="modal-section">
            <h4 data-i18n="help_panels">â†”ï¸ Panels</h4>
            <p data-i18n="help_panels_body">On desktop, you can click the <b>â€¹</b> icon on the "Answers" panel to collapse and expand it.</p>
        </div>
    </div>
  </div>

  <div id="wordListModal" class="modal">
     <div class="modal-content" role="dialog" aria-modal="true" tabindex="-1">
      <div class="modal-header"><h2 data-i18n="word_list_modal_title">Current Word List</h2><button class="icon-btn close-btn" data-i18n-title="label_close" data-i18n-aria-label="label_close" aria-label="Close" title="Close">&times;</button></div>
      <div class="word-list" id="wordListContent"></div>
    </div>
  </div>
  
  <div id="historyModal" class="modal">
     <div class="modal-content" role="dialog" aria-modal="true" tabindex="-1">
      <div class="modal-header"><h2 data-i18n="history_title">Answers</h2><button class="icon-btn close-btn" data-i18n-title="label_close" data-i18n-aria-label="label_close" aria-label="Close" title="Close">&times;</button></div>
      <div id="historyModalContent" class="word-list"></div>
    </div>
  </div>

  <!-- App Menu: mobile-friendly hamburger contents -->
  <div id="menuModal" class="modal">
    <!-- floating close aligned to hamburger -->
    <button id="menuCloseOverlay" aria-label="Close" title="Close">âœ•</button>
    <div class="modal-content" role="dialog" aria-modal="true" tabindex="-1">
      <div class="menu-shell">
        <section id="menuPanel" class="panel" aria-hidden="true" role="dialog" aria-modal="true" aria-labelledby="menuPanelTitle">
          <div class="panel-header">
            <h2 id="menuPanelTitle" style="margin:0">Menu</h2>
          </div>
          <div class="panel-body">
      <div class="modal-section">
        <label style="display:block; font-weight:600; margin-bottom:0.25rem;">Language</label>
        <div class="language-flags" style="display:flex; gap:0.75rem;">
          <button type="button" class="language-flag" id="menuLangEn" aria-label="English" title="English">ğŸ‡ºğŸ‡¸</button>
          <button type="button" class="language-flag" id="menuLangFr" aria-label="FranÃ§ais" title="FranÃ§ais">ğŸ‡«ğŸ‡·</button>
        </div>
      </div>
      <div class="modal-section menu-field">
        <div class="switch-row"><input type="checkbox" id="shuffleToggle"><label for="shuffleToggle" data-i18n="label_shuffle">Shuffle words</label></div>
      </div>
      <div class="modal-section menu-field">
        <label for="studyModeSelect" data-i18n="label_studyMode">Study Mode:</label>
        <select id="studyModeSelect" style="width:100%; padding:0.5rem;">
          <option value="listenRead" data-i18n="mode_listen_read">Listen and read</option>
          <option value="readThenSay" data-i18n="mode_read_then_say">Read then say</option>
          <option value="listenThenRepeat" data-i18n="mode_listen_then_repeat">Listen then repeat</option>
          <option value="articlesDef" data-i18n="mode_articles_def">Articles dÃ©finis (le/la)</option>
          <option value="articlesIndef" data-i18n="mode_articles_indef">Articles indÃ©finis (un/une)</option>
        </select>
      </div>
      <div class="modal-section menu-field">
        <label for="voiceSelect" data-i18n="label_voice">Voice:</label>
        <select id="voiceSelect" style="width: 100%; padding: 0.5rem;"></select>
        <div style="display:flex; gap:.5rem; align-items:center; margin-top:.5rem; flex-wrap:wrap;">
          <button class="btn btn-secondary" id="voiceTestBtn" type="button" data-i18n="btn_test_voice">Test Voice</button>
          <div id="iosVoiceHint" class="ios-voice-hint" data-i18n="voice_hint_ios" style="display:none; font-size: 0.85em; color: #777;">
            Tip (iOS): After the first playback, reopen Settings to refresh French voices.
          </div>
        </div>
      </div>
      <div class="modal-section menu-field">
        <details id="menuFiles" style="width:100%;">
          <summary style="cursor:pointer; font-weight:700;">Files</summary>
          <div id="menuWordListsSection" class="menu-field" style="margin-top:0.5rem;">
            <label>Active Word Lists</label>
            <div id="menuWordListsOptions" class="word-lists-options"></div>
          </div>
          <div style="margin-top:0.5rem;">
            <label for="menuFileInput" style="display:block; font-weight:600; margin-bottom:0.25rem;">Add .txt files</label>
            <input type="file" id="menuFileInput" accept=".txt" multiple />
            <div style="font-size:0.85em; color:#777; margin-top:0.25rem;">Tip: You can also drag & drop files anywhere on the page.</div>
          </div>
        </details>
      </div>
      <hr/>
      <div class="menu-bottom" style="margin-top:auto;">
        <div class="modal-section menu-list" style="margin-top:0;">
          <button id="menuHelpBtn">Help</button>
        </div>
        <div id="menuVersion" class="version-inline" style="padding-bottom:0.5rem;"></div>
      </div>
    </div>
  </div>

  <div id="confirmationDialog" class="modal">
    <div class="modal-content" style="text-align: center;" role="dialog" aria-modal="true" tabindex="-1">
      <h3 data-i18n="confirm_title">Reset Study Progress</h3>
      <p id="confirmationDialogText"></p>
      <div style="display: flex; justify-content: center; gap: 1rem; margin-top: 1rem;">
        <button class="btn btn-primary" id="confirmReset" data-i18n="confirm_yes_continue">Yes, Continue</button>
        <button class="btn btn-secondary" id="cancelReset" data-i18n="confirm_cancel">Cancel</button>
      </div>
    </div>
  </div>

  <div id="toastNotification" class="toast"></div>
  <div id="appVersionCorner" class="app-version-corner"></div>

<script>
    'use strict';
    const i18n = {
      en: {
        page_title: "ğŸ‡«ğŸ‡· French Listening Study",
        header_title: "ğŸ‡«ğŸ‡· French Study",
        title_help: "Help",
        title_settings: "Settings",
        title_toggle_history: "Toggle History Panel",
        welcome_message: "Welcome!",
        btn_view_list: "View List",
        btn_history: "History",
        status_load_prompt: "Load a word list to start.",
        file_info_none: "No file loaded.",
        welcome_title: "Welcome to the French Study App!",
        welcome_instructions: "To begin, please load one or more `.txt` files containing your words.",
        welcome_drag_drop: "Drag & Drop File(s) Here",
        welcome_or: "or",
        welcome_browse: "Browse Files",
        settings_title: "Settings",
        label_active_word_lists: "Active Word Lists",
        btn_next: "Next (Space)", btn_repeat: "Repeat (R)", btn_show: "Show (S)", btn_toggleVoice: "Voice (V)",
        status_ready: "Ready to start a new session", history_title: "Answers",
        label_voice: "Voice:", label_studyMode: "Study Mode:",
        label_shuffle: "Shuffle words", label_seconds: "seconds",
        mode_simultaneous: "Listen and Read simultaneously",
        mode_listen_read: "Listen and read",
        mode_read_then_say: "Read then say",
        mode_listen_then_repeat: "Listen then repeat",
        mode_articles_def: "Definite articles (le/la)",
        mode_articles_indef: "Indefinite articles (un/une)",
        btn_prefix_un: "Prefix: un",
        btn_prefix_une: "Prefix: une",
        btn_prefix_le: "Prefix: le",
        btn_prefix_la: "Prefix: la",
        prefix_prompt: "Choose the correct prefix (un/une)",
        toast_correct_prefix: "âœ… Correct! {prefix} + {base}",
        toast_wrong_prefix: "âŒ Not quite. It was {prefix} + {base}",
        help_title: "Help",
        word_list_modal_title: "Current Word List",
        help_getting_started: "ğŸš€ Getting Started",
        help_getting_started_body: "Load a word list by dragging one or more <code>.txt</code> files onto the page, or by clicking the welcome screen to browse your files.",
        help_main_controls: "ğŸ® Main Controls",
        help_main_controls_next: "<b>Next (Space):</b> Proceeds to the next word.",
        help_main_controls_repeat: "<b>Repeat (R):</b> Repeats the audio for the current word.",
        help_main_controls_show: "<b>Show (S):</b> Instantly reveals the text of the current word.",
        help_privative_title: "ğŸ§© Privative Prefix Quiz",
        help_privative_body: "When your list has words that begin with <b>un</b> or <b>une</b>, enable the Privative Prefix mode in Settings. You will see the base word like â€œ<b>â€¦</b> amiâ€. Choose the correct prefix with the buttons. If you skip, the answer is recorded as â€œ<b>â€¦</b> amiâ€ in Answers.",
        help_settings: "âš™ï¸ Settings",
        help_settings_body: "Click the gear icon to manage settings. You can choose from different study modes, select voices, and enable/disable your loaded word lists for the current session.",
        help_panels: "â†”ï¸ Panels",
        help_panels_body: "On desktop, you can click the <b>â€¹</b> icon on the \"Answers\" panel to collapse and expand it.",
        btn_test_voice: "Test Voice",
        label_close: "Close",
        test_phrase: "Bonjour !",
        voice_hint_ios: "Tip (iOS): After first playback, reopen Settings to refresh French voices.",
        confirm_title: "Reset Study Progress",
        confirm_yes_continue: "Yes, Continue",
        confirm_cancel: "Cancel",
        no_voices: "ğŸ—£ï¸ No Voices Available",
        indicator_mode_prefix: "ğŸ“– Mode:",
        indicator_shuffle_on: "ğŸ”€ Shuffle: On",
        indicator_shuffle_off: "â¡ï¸ Shuffle: Off",
        status_word_progress: "Word {current}/{total}",
        opt_system_french_voice: "System Default French Voice",
        words_lower: "words",
        file_info: "{wordCount} words from {fileCount} file(s)",
        history_empty: "No words have been revealed yet in this session.",
        restart_message: "ğŸ‰ Starting over from the beginning.", listening: "Listening...", reveal_prompt: "???", ready_to_start: "Ready to start!",
        instr_listen: "Listen please.",
        instr_repeat: "Repeat what you did hear.",
        instr_read_say: "Say what you read.",
        instr_skip_next: "You may skip to the next word.",
        session_complete: "ğŸ‰ Session Complete!", start_next_session: "Start Next (Space)",
        toast_single_file: "âœ… {count} words loaded â€“ ready to study!",
        toast_multi_file: "âœ… {wordCount} words from {fileCount} files loaded â€“ ready to study!",
        confirm_shuffle: "Changing shuffle mode will reset your progress. Are you sure?",
        confirm_word_list: "Changing active word lists will reset your progress. Are you sure?"
      },
      fr: {
        page_title: "ğŸ‡«ğŸ‡· Ã‰tude d'Ã©coute en franÃ§ais",
        header_title: "ğŸ‡«ğŸ‡· Ã‰tude de franÃ§ais",
        title_help: "Aide",
        title_settings: "ParamÃ¨tres",
        title_toggle_history: "Basculer le panneau d'historique",
        welcome_message: "Bienvenue !",
        btn_view_list: "Voir la liste",
        btn_history: "Historique",
        status_load_prompt: "Chargez une liste de mots pour commencer.",
        file_info_none: "Aucun fichier chargÃ©.",
        welcome_title: "Bienvenue dans l'application d'Ã©tude de franÃ§ais !",
        welcome_instructions: "Pour commencer, chargez un ou plusieurs fichiers `.txt` contenant vos mots.",
        welcome_drag_drop: "Glissez-dÃ©posez les fichiers ici",
        welcome_or: "ou",
        welcome_browse: "Parcourir les fichiers",
        settings_title: "ParamÃ¨tres",
        label_active_word_lists: "Listes de mots actives",
        btn_next: "Suivant (Espace)", btn_repeat: "RÃ©pÃ©ter (R)", btn_show: "Afficher (S)", btn_toggleVoice: "Voix (V)",
        status_ready: "PrÃªt Ã  commencer une nouvelle session", history_title: "RÃ©ponses",
        label_voice: "Voix :", label_studyMode: "Mode d'Ã©tude :",
        label_shuffle: "MÃ©langer les mots", label_seconds: "secondes",
        mode_simultaneous: "Ã‰couter et lire simultanÃ©ment",
        mode_listen_read: "Ã‰couter et lire",
        mode_read_then_say: "Lire puis dire",
        mode_listen_then_repeat: "Ã‰couter puis rÃ©pÃ©ter",
        mode_articles_def: "Articles dÃ©finis (le/la)",
        mode_articles_indef: "Articles indÃ©finis (un/une)",
        btn_prefix_un: "PrÃ©fixe : un",
        btn_prefix_une: "PrÃ©fixe : une",
        btn_prefix_le: "PrÃ©fixe : le",
        btn_prefix_la: "PrÃ©fixe : la",
        prefix_prompt: "Choisissez le bon prÃ©fixe (un/une)",
        toast_correct_prefix: "âœ… Correct ! {prefix} + {base}",
        toast_wrong_prefix: "âŒ Pas tout Ã  fait. C'Ã©tait {prefix} + {base}",
        help_title: "Aide",
        word_list_modal_title: "Liste de mots actuelle",
        help_getting_started: "ğŸš€ Pour commencer",
        help_getting_started_body: "Chargez une liste de mots en faisant glisser un ou plusieurs fichiers <code>.txt</code> sur la page, ou cliquez sur l'Ã©cran d'accueil pour parcourir vos fichiers.",
        help_main_controls: "ğŸ® ContrÃ´les principaux",
        help_main_controls_next: "<b>Suivant (Espace):</b> Passe au mot suivant.",
        help_main_controls_repeat: "<b>RÃ©pÃ©ter (R):</b> RÃ©pÃ¨te l'audio du mot actuel.",
        help_main_controls_show: "<b>Afficher (S):</b> RÃ©vÃ¨le instantanÃ©ment le texte du mot actuel.",
        help_privative_title: "ğŸ§© PrÃ©fixe privatif",
        help_privative_body: "Lorsque votre liste contient des mots commenÃ§ant par <b>un</b> ou <b>une</b>, activez le mode PrÃ©fixe privatif dans les ParamÃ¨tres. Vous verrez le mot de base comme Â« <b>â€¦</b> ami Â». Choisissez le bon prÃ©fixe avec les boutons. Si vous passez, la rÃ©ponse est enregistrÃ©e comme Â« <b>â€¦</b> ami Â» dans RÃ©ponses.",
        help_settings: "âš™ï¸ ParamÃ¨tres",
        help_settings_body: "Cliquez sur l'icÃ´ne d'engrenage pour gÃ©rer les paramÃ¨tres. Vous pouvez choisir diffÃ©rents modes d'Ã©tude, sÃ©lectionner des voix et activer/dÃ©sactiver vos listes de mots chargÃ©es pour la session en cours.",
        help_panels: "â†”ï¸ Panneaux",
        help_panels_body: "Sur ordinateur, vous pouvez cliquer sur l'icÃ´ne <b>â€¹</b> du panneau \"RÃ©ponses\" pour le rÃ©duire ou l'agrandir.",
        btn_test_voice: "Tester la voix",
        label_close: "Fermer",
        test_phrase: "Bonjour !",
        voice_hint_ios: "Astuce (iOS) : AprÃ¨s la premiÃ¨re lecture, rouvrez ParamÃ¨tres pour actualiser les voix franÃ§aises.",
        confirm_title: "RÃ©initialiser la progression d'Ã©tude",
        confirm_yes_continue: "Oui, continuer",
        confirm_cancel: "Annuler",
        no_voices: "ğŸ—£ï¸ Aucune voix disponible",
        indicator_mode_prefix: "ğŸ“– Mode :",
        indicator_shuffle_on: "ğŸ”€ MÃ©lange : ActivÃ©",
        indicator_shuffle_off: "â¡ï¸ MÃ©lange : DÃ©sactivÃ©",
        status_word_progress: "Mot {current}/{total}",
        opt_system_french_voice: "Voix franÃ§aise par dÃ©faut du systÃ¨me",
        words_lower: "mots",
        file_info: "{wordCount} mots de {fileCount} fichier(s)",
        history_empty: "Aucun mot n'a encore Ã©tÃ© rÃ©vÃ©lÃ© dans cette session.",
        restart_message: "ğŸ‰ Reprise depuis le dÃ©but.", listening: "Ã‰coute...", reveal_prompt: "???", ready_to_start: "PrÃªt Ã  commencer !",
        instr_listen: "Veuillez Ã©couter.",
        instr_repeat: "RÃ©pÃ©tez ce que vous avez entendu.",
        instr_read_say: "Dites ce que vous lisez.",
        instr_skip_next: "Vous pouvez passer au mot suivant.",
        session_complete: "ğŸ‰ Session terminÃ©e !", start_next_session: "Commencer (Espace)",
        toast_single_file: "âœ… {count} mots chargÃ©s â€“ prÃªt Ã  Ã©tudier !",
        toast_multi_file: "âœ… {wordCount} mots de {fileCount} fichiers chargÃ©s â€“ prÃªt Ã  Ã©tudier !",
        confirm_shuffle: "Changer le mode de mÃ©lange rÃ©initialisera votre progression. C'est certain ?",
        confirm_word_list: "Changer les listes de mots actives rÃ©initialisera votre progression. C'est certain ?"
      }
    };

    // --- GLOBAL VARIABLES ---
    let wordLists = {}; // { filename: { words: [], enabled: true } }
    let words = [], currentIndex = 0, currentWord = "";
    let availableVoices = [], currentVoice = "system", displayHistory = [];
    let studyMode = "listenThenRepeat"; // default
    // Deprecated timer settings removed
    let countdownInterval = null;
    let isInSpeakFirstMode = false; // legacy; no longer used for timers
    let readSayStage = 0; // 0=new word, 1=shown, 2=spoken (advance next)
    let listenRepeatStage = 0; // 0=new word, 1=awaiting user after speak, 2=word shown awaiting next
    let shuffleEnabled = false;
    let originalWordOrder = [];
    let isSessionComplete = false;
    const APP_VERSION = 'v1.1.8-beta';
    // Articles quiz state
    let prefixWords = [];
    let prefixWordsIndef = [];
    let prefixWordsDef = [];
    let prefixIndex = 0;
    let currentBaseWord = "";
    let currentExpectedPrefix = ""; // 'un' or 'une'
    let privativeAnswered = true;
    const synth = window.speechSynthesis;
    let curLang = "en";
    let confirmationCallback = null;

    // --- ENV / BROWSER DETECTION ---
    const UA = navigator.userAgent || '';
    const isIOS = /iPad|iPhone|iPod/.test(UA) || (/Macintosh/.test(UA) && 'ontouchend' in document);
    const isFirefox = /Firefox\/\d+/.test(UA);
    const isChromium = !isIOS && /(Chrome|Chromium|Edg|Brave)\//.test(UA) && !/OPR\//.test(UA);
    const isSafari = !isChromium && (/Safari\//.test(UA) || isIOS);

    // --- DOM ELEMENTS ---
    const progressCircle = document.querySelector('.progress-ring__circle');
    const radius = progressCircle.r.baseVal.value;
    const circumference = radius * 2 * Math.PI;
    progressCircle.style.strokeDasharray = `${circumference} ${circumference}`;
    progressCircle.style.strokeDashoffset = circumference;
    const allModals = document.querySelectorAll('.modal');
    const progressBarFill = document.getElementById('progressBarFill');
    const countdownTopbarFill = document.getElementById('countdownTopbarFill');
    const nextBtn = document.getElementById('nextBtn');
    const repeatBtn = document.getElementById('repeatBtn');
    const showBtn = document.getElementById('showBtn');
    const voiceBtn = document.getElementById('voiceBtn');
    const welcomeModal = document.getElementById('welcomeModal');
    const settingsModal = document.getElementById('settingsModal');
    const helpModal = document.getElementById('helpModal');
    const wordListModal = document.getElementById('wordListModal');
    const confirmationDialog = document.getElementById('confirmationDialog');
    const toastNotification = document.getElementById('toastNotification');
    const historyModal = document.getElementById('historyModal');
    const historyModalContent = document.getElementById('historyModalContent');
    const historyBtn = document.getElementById('historyBtn');


    // --- CORE FUNCTIONS ---
    function setLanguage(lang) {
      curLang = lang;
      document.getElementById('langEn').classList.toggle('active', lang === 'en');
      document.getElementById('langFr').classList.toggle('active', lang === 'fr');
      // mirror selection in menu flags if present
      const mEn = document.getElementById('menuLangEn');
      const mFr = document.getElementById('menuLangFr');
      if (mEn && mFr) { mEn.classList.toggle('active', lang === 'en'); mFr.classList.toggle('active', lang === 'fr'); }
      document.querySelectorAll("[data-i18n]").forEach(el => {
        const key = el.getAttribute("data-i18n");
        if (i18n[lang] && i18n[lang][key]) {
          const val = i18n[lang][key];
          if (/[<>&]/.test(val)) {
            el.innerHTML = val;
          } else {
            el.textContent = val;
          }
        }
      });
      document.querySelectorAll('[data-i18n-title]').forEach(el => {
        const key = el.getAttribute('data-i18n-title');
        if (i18n[lang] && i18n[lang][key]) {
          el.setAttribute('title', i18n[lang][key]);
        }
      });
      document.querySelectorAll('[data-i18n-aria-label]').forEach(el => {
        const key = el.getAttribute('data-i18n-aria-label');
        if (i18n[lang] && i18n[lang][key]) {
          el.setAttribute('aria-label', i18n[lang][key]);
        }
      });
      if (words.length > 0) {
        const msg = i18n[lang].status_word_progress.replace('{current}', currentIndex).replace('{total}', words.length);
        updateStatusInfo(msg);
      } else {
        updateStatusInfo(i18n[lang].status_load_prompt);
      }
      updateAllIndicators();
    }
    
    function populateVoiceList() {
        const voices = synth.getVoices();
        if (voices.length > 0) {
            loadVoices(voices);
        } else {
            synth.onvoiceschanged = () => {
                const updatedVoices = synth.getVoices();
                loadVoices(updatedVoices);
            };
        }
    }

    function scoreFrenchVoice(voice) {
      const name = (voice.name || '').toLowerCase();
      const lang = (voice.lang || '').toLowerCase();
      const uri = (voice.voiceURI || '').toLowerCase();
      let score = 0;
      // Language match priority
      if (lang.startsWith('fr-fr')) score += 40;
      else if (lang.startsWith('fr-ca')) score += 30;
      else if (lang.startsWith('fr')) score += 20; // fr-be, fr-ch, etc.
      // Prefer local installed voices
      if (voice.localService) score += 10;
      // Prefer high quality indicators in name/URI (Safari often encodes in URI)
      if (name.includes('siri') || uri.includes('siri')) score += 60;
      if (name.includes('premium') || uri.includes('premium')) score += 50;
      if (name.includes('enhanced') || uri.includes('enhanced')) score += 40;
      if (name.includes('neural') || uri.includes('neural') || name.includes('hq') || uri.includes('hq')) score += 30;
      if (uri.includes('compact')) score -= 20; // penalize compact quality
      if (voice.default) score += 10;
      return score;
    }

    function bestFrenchVoice() {
      if (!availableVoices || availableVoices.length === 0) return null;
      const fr = availableVoices.filter(v => (v.lang || '').toLowerCase().startsWith('fr'));
      if (fr.length === 0) return null;
      // Safari preference: Thomas if available
      if (isSafari) {
        const thomas = fr.filter(v => (v.name || '').toLowerCase().includes('thomas'))
                         .sort((a, b) => scoreFrenchVoice(b) - scoreFrenchVoice(a));
        if (thomas.length) return thomas[0];
      }
      return fr.sort((a, b) => scoreFrenchVoice(b) - scoreFrenchVoice(a))[0] || null;
    }

    function loadVoices(voices) {
      availableVoices = voices;
      const vs = document.getElementById("voiceSelect");
      
      vs.innerHTML = ''; 

      const defaultOption = document.createElement("option");
      defaultOption.value = "system";
      defaultOption.textContent = i18n[curLang].opt_system_french_voice;
      vs.appendChild(defaultOption);
      const allFrench = availableVoices
        .filter(v => (v.lang || '').toLowerCase().startsWith('fr'));
      const qualityKeywords = ['siri', 'enhanced', 'premium', 'neural', 'hq', 'audrey', 'amelie', 'thomas'];

      let toShow = [];
      if (isFirefox) {
        // Firefox: prefer high-quality filtered list; fallback to all FR
        const high = allFrench.filter(v => qualityKeywords.some(k => (v.name || '').toLowerCase().includes(k)));
        toShow = (high.length ? high : allFrench).sort((a, b) => scoreFrenchVoice(b) - scoreFrenchVoice(a));
      } else if (isChromium) {
        // Chromium: previous behavior was betterâ€”if we can't positively identify HQ voices,
        // don't list potentially poor ones. Only list if we find HQ matches; otherwise keep only System.
        const high = allFrench.filter(v => qualityKeywords.some(k => (v.name || '').toLowerCase().includes(k)));
        toShow = high.sort((a, b) => scoreFrenchVoice(b) - scoreFrenchVoice(a));
        // Best-effort: if user previously selected a specific FR voice and it exists, include it
        if (toShow.length === 0 && currentVoice && currentVoice !== 'system') {
          const saved = allFrench.find(v => v.name === currentVoice);
          if (saved) toShow = [saved];
        }
      } else if (isSafari) {
        // Safari (incl. iOS): list all FR voices, sorted by quality (Siri/Enhanced first)
        toShow = allFrench.sort((a, b) => scoreFrenchVoice(b) - scoreFrenchVoice(a));
      } else {
        // Default: show all FR voices
        toShow = allFrench.sort((a, b) => scoreFrenchVoice(b) - scoreFrenchVoice(a));
      }

      toShow.forEach(voice => {
        const opt = document.createElement("option");
        opt.value = voice.name;
        opt.textContent = `${voice.name} (${voice.lang})`;
        vs.appendChild(opt);
      });

      // Preserve current selection if possible
      let existingIndex = Array.from(vs.options).findIndex(o => o.value === currentVoice);
      if (existingIndex >= 0) {
        vs.selectedIndex = existingIndex;
      } else if (isSafari) {
        // Make Thomas default for Safari if present
        const thomasIndex = Array.from(vs.options).findIndex(o => (o.value || '').toLowerCase().includes('thomas'));
        if (thomasIndex > 0) {
          vs.selectedIndex = thomasIndex;
          currentVoice = vs.options[thomasIndex].value;
        } else {
          vs.selectedIndex = 0;
          currentVoice = 'system';
        }
      } else {
        vs.selectedIndex = 0;
        currentVoice = 'system';
      }

      updateVoiceIndicator();
      renderVoiceDebug();
    }

    async function handleFileLoad(files) {
        let totalWords = 0;

        const readFile = (file) => new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (event) => resolve(event.target.result);
            reader.onerror = (error) => reject(error);
            reader.readAsText(file);
        });

        for (const file of files) {
            try {
                const content = await readFile(file);
                const fileWords = content.split("\n").filter(w => w.trim());
                if (fileWords.length > 0) {
                  wordLists[file.name] = { words: fileWords, enabled: true };
                  totalWords += fileWords.length;
                }
            } catch (err) {
                showToast(`Error: Could not load ${file.name}.`);
            }
        }

        if (totalWords > 0) {
            generateWordListsUI();
            rebuildActiveWordsList();
            welcomeModal.classList.remove('visible');

            let toastMessage;
            const fileCount = Object.keys(wordLists).length;

            if (fileCount === 1) {
                toastMessage = i18n[curLang].toast_single_file.replace('{count}', totalWords);
            } else {
                toastMessage = i18n[curLang].toast_multi_file.replace('{wordCount}', totalWords).replace('{fileCount}', fileCount);
            }
            showToast(toastMessage);
        }
    }
    
    function shuffleArray(a) { for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[a[i], a[j]] = [a[j], a[i]]; } }

    function initializeStudy() {
      isSessionComplete = false;
      currentIndex = 0;
      currentWord = "";
      readSayStage = 0;
      listenRepeatStage = 0;
      prefixIndex = 0;
      currentBaseWord = "";
      currentExpectedPrefix = "";
      privativeAnswered = true;
      displayHistory = [];
      ['nextBtn', 'repeatBtn', 'showBtn', 'voiceBtn', 'historyBtn'].forEach(id => document.getElementById(id).disabled = words.length === 0);
      document.getElementById('viewListBtn').disabled = words.length === 0;
      nextBtn.textContent = i18n[curLang].btn_next;
      updateStatusInfo('');
      updateDisplayUpper(i18n[curLang].ready_to_start);
      updateInstruction('');
      updateHistoryList();
      updateProgressBar();
      document.getElementById('countdownText').textContent = '--';
      if (countdownTopbarFill) countdownTopbarFill.style.width = '0%';
      // Toggle privative controls visibility
      document.getElementById('privativeControls').style.display = (getSelectedStudyMode() === 'articlesIndef' || getSelectedStudyMode() === 'articlesDef') ? 'flex' : 'none';
      // Set initial labels for prefix buttons according to mode
      (function(){
        const unBtnLbl = document.getElementById('prefixUnBtn');
        const uneBtnLbl = document.getElementById('prefixUneBtn');
        if (unBtnLbl && uneBtnLbl) {
          if (getSelectedStudyMode() === 'articlesDef') { unBtnLbl.textContent = i18n[curLang].btn_prefix_le || 'Prefix: le'; uneBtnLbl.textContent = i18n[curLang].btn_prefix_la || 'Prefix: la'; }
          else { unBtnLbl.textContent = i18n[curLang].btn_prefix_un; uneBtnLbl.textContent = i18n[curLang].btn_prefix_une; }
        }
      })();
      // Shuffle questions for articles mode according to shuffleEnabled
      if ((getSelectedStudyMode() === 'articlesIndef' || getSelectedStudyMode() === 'articlesDef') && prefixWords.length > 0) {
        if (shuffleEnabled) shuffleArray(prefixWords);
        else if (window.prefixOriginalOrder) prefixWords = [...window.prefixOriginalOrder];
      }
    }

    function speakWord(w) {
      if (synth.speaking) synth.cancel();
      const u = new SpeechSynthesisUtterance(w);
      let selectedVoice = null;
      if (currentVoice && currentVoice !== 'system') {
        selectedVoice = availableVoices.find(v => v.name === currentVoice) || null;
      }
      if (!selectedVoice) {
        if (isChromium) {
          // On Chromium, letting the platform pick often yields a highâ€‘quality FR voice; avoid overriding.
          u.lang = 'fr-FR';
        } else {
          // On Safari/Firefox, resolve best French voice explicitly to ensure quality.
          const best = bestFrenchVoice();
          if (best) {
            selectedVoice = best;
            u.voice = best;
            u.lang = best.lang || 'fr-FR';
          } else {
            u.lang = 'fr-FR';
          }
        }
      } else {
        u.voice = selectedVoice;
        u.lang = selectedVoice.lang || 'fr-FR';
      }
      u.rate = 0.9;
      return new Promise(resolve => { 
        u.onend = resolve; 
        synth.speak(u); 
        // After first synthesis, some browsers populate voices; try to refresh list lazily
        if (!availableVoices || availableVoices.length === 0 || document.getElementById('voiceSelect').options.length <= 1) {
          setTimeout(populateVoiceList, 0);
        }
      });
    }

    function startCountdown(seconds) {
      if (countdownInterval) clearInterval(countdownInterval);
      progressCircle.style.transition = 'stroke-dashoffset 0.1s linear';
      
      const countdownTextEl = document.getElementById('countdownText');
      const totalDuration = seconds * 1000;
      let startTime = Date.now();
      if (countdownTopbarFill) countdownTopbarFill.style.width = '100%';

      countdownInterval = setInterval(() => {
        const elapsedTime = Date.now() - startTime;
        if (elapsedTime >= totalDuration) {
          clearInterval(countdownInterval);
          progressCircle.style.strokeDashoffset = circumference;
          countdownTextEl.textContent = '--';
          if (countdownTopbarFill) countdownTopbarFill.style.width = '0%';
          if (isInSpeakFirstMode && currentWord) {
            updateDisplayUpper(currentWord);
            addToHistory(currentWord);
            isInSpeakFirstMode = false;
          }
        } else {
          const progress = elapsedTime / totalDuration;
          const offset = circumference - (progress * circumference);
          progressCircle.style.strokeDashoffset = offset;
          const secondsLeft = Math.ceil((totalDuration - elapsedTime) / 1000);
          countdownTextEl.textContent = `${secondsLeft}s`;
          if (countdownTopbarFill) countdownTopbarFill.style.width = `${Math.max(0, (1 - progress) * 100)}%`;
        }
      }, 50);
    }

    function updateHistoryList() {
      const historyList = document.getElementById("historyList");
      historyList.innerHTML = "";
      if (displayHistory.length === 0) return;
      displayHistory.forEach(item => {
        const historyItem = document.createElement("div");
        historyItem.className = "history-item";
        historyItem.textContent = item;
        historyList.appendChild(historyItem);
      });
      historyList.scrollTop = historyList.scrollHeight;
    }

    function addToHistory(word) {
      const modeNow = getSelectedStudyMode();
      const isArticles = (modeNow === 'articlesIndef' || modeNow === 'articlesDef');
      const indexNum = isArticles ? prefixIndex : currentIndex;
      const historyEntry = `${indexNum}: ${word}`;
      if (!displayHistory.includes(historyEntry)) {
        displayHistory.push(historyEntry);
        updateHistoryList();
      }
    }

    async function nextWord() {
      if (!words.length) return;
      // Articles mode branch (le/la or un/une)
      if (getSelectedStudyMode() === 'articlesIndef' || getSelectedStudyMode() === 'articlesDef') {
        prefixWords = (getSelectedStudyMode() === 'articlesIndef') ? prefixWordsIndef : prefixWordsDef;
        window.prefixOriginalOrder = (getSelectedStudyMode() === 'articlesIndef') ? window.prefixOriginalOrderIndef : window.prefixOriginalOrderDef;
        if (prefixWords.length === 0) return;
        // If previous question existed and was not answered, record as unanswered
        if (currentBaseWord && !privativeAnswered) {
          addToHistory(`â€¦ ${currentBaseWord}`);
        }
        if (prefixIndex >= prefixWords.length) {
          // Restart automatically for privative quiz
          showToast(i18n[curLang].restart_message);
          // Clear Answers modal/history on restart
          displayHistory = [];
          updateHistoryList();
          prefixIndex = 0;
          if (shuffleEnabled) shuffleArray(prefixWords); else if (window.prefixOriginalOrder) prefixWords = [...window.prefixOriginalOrder];
          setTimeout(() => nextWord(), 0);
          return;
        }
        const item = prefixWords[prefixIndex];
        currentWord = item.full;
        currentBaseWord = item.base;
        currentExpectedPrefix = item.prefix;
        privativeAnswered = false;
        prefixIndex++;
        updateProgressBar();
        // Display placeholder for prefix
        updateDisplayUpper(`â€¦ ${currentBaseWord}`);
        // Speak base word only
        await speakWord(currentBaseWord);
        updateStatusInfo(i18n[curLang].status_word_progress.replace('{current}', prefixIndex).replace('{total}', prefixWords.length));
        return;
      }
      // For Listen & Repeat: add the previously spoken word to Answers when advancing
      if (!isSessionComplete && getSelectedStudyMode() === 'listenThenRepeat' && currentWord) {
        addToHistory(currentWord);
      }
      if (isSessionComplete) {
        if (shuffleEnabled) shuffleArray(words);
        initializeStudy();
        return;
      }

      if (currentIndex >= words.length) {
        isSessionComplete = true;
        updateDisplayUpper(i18n[curLang].session_complete, true);
        updateInstruction('');
        nextBtn.textContent = i18n[curLang].start_next_session;
        updateProgressBar();
        ['repeatBtn', 'showBtn', 'voiceBtn'].forEach(id => document.getElementById(id).disabled = true);
        return;
      }

      // Handle staged flow for Read & Say: if we are in stages 1 or 2
      if (getSelectedStudyMode() === 'readThenSay' && currentWord) {
        if (readSayStage === 1) {
          await speakWord(currentWord); // speak after the student reads
          updateInstruction(i18n[curLang].instr_skip_next);
          readSayStage = 2;
          return; // wait for another Next to advance
        } else if (readSayStage === 2) {
          // proceed to pick the next word
          readSayStage = 0;
        }
      }

      // Handle staged flow for Listen then Repeat
      if (getSelectedStudyMode() === 'listenThenRepeat' && currentWord) {
        if (listenRepeatStage === 1) {
          // Reveal the word after the student repeats and speak it once more
          updateDisplayUpper(currentWord);
          await speakWord(currentWord);
          updateInstruction(i18n[curLang].instr_skip_next);
          listenRepeatStage = 2; // wait for next press to advance (pre-add will log previous)
          return;
        } else if (listenRepeatStage === 2) {
          // proceed to pick the next word
          listenRepeatStage = 0;
        }
      }

      currentWord = words[currentIndex];
      currentIndex++;
      updateProgressBar();

      studyMode = getSelectedStudyMode();

      if (studyMode === "listenRead") {
        updateDisplayUpper(currentWord);
        addToHistory(currentWord);
        updateInstruction('');
        await speakWord(currentWord);
      } else if (studyMode === "readThenSay") {
        // Stage 1: show the word, wait for student to say it
        updateDisplayUpper(currentWord);
        addToHistory(currentWord);
        updateInstruction(i18n[curLang].instr_read_say);
        readSayStage = 1; // next press will speak
        updateStatusInfo(i18n[curLang].status_word_progress.replace('{current}', currentIndex).replace('{total}', words.length));
        return;
      } else if (studyMode === "listenThenRepeat") {
        updateDisplayUpper(i18n[curLang].reveal_prompt);
        updateInstruction(i18n[curLang].instr_listen);
        await speakWord(currentWord); // speak first
        updateInstruction(i18n[curLang].instr_repeat);
        listenRepeatStage = 1; // now wait for user to reveal
        return;
      }
      updateStatusInfo(i18n[curLang].status_word_progress.replace('{current}', currentIndex).replace('{total}', words.length));
    }

    async function repeatWord() { 
      if (!currentWord) return; 
      if ((getSelectedStudyMode() === 'articlesIndef' || getSelectedStudyMode() === 'articlesDef') && currentBaseWord) {
        await speakWord(currentBaseWord);
      } else {
        await speakWord(currentWord);
      }
    }

    function showCurrentWord() {
      if (currentWord) {
        if ((getSelectedStudyMode() === 'articlesIndef' || getSelectedStudyMode() === 'articlesDef') && currentBaseWord) {
          const full = `${currentExpectedPrefix} ${currentBaseWord}`;
          updateDisplayUpper(full);
          addToHistory(full);
          // Speak the full phrase when revealed via Show
          speakWord(full);
          privativeAnswered = true;
          return;
        }
        updateDisplayUpper(currentWord);
        isInSpeakFirstMode = false;
        addToHistory(currentWord);
      }
    }

    function toggleVoice() {
      const vs = document.getElementById("voiceSelect");
      if (vs.options.length === 0) return;
      vs.selectedIndex = (vs.selectedIndex + 1) % vs.options.length;
      currentVoice = vs.value;
      try { localStorage.setItem('selectedVoice', currentVoice); } catch (_) {}
      updateVoiceIndicator();
      renderVoiceDebug();
    }
    
    // --- UI UPDATE & MANAGEMENT FUNCTIONS ---
    function updateProgressBar() {
        let progress = 0;
        const modeNow = getSelectedStudyMode();
        if (modeNow === 'articlesIndef' || modeNow === 'articlesDef') {
          const active = (modeNow === 'articlesIndef') ? prefixWordsIndef : prefixWordsDef;
          progress = active.length > 0 ? (prefixIndex / active.length) * 100 : 0;
        } else {
          progress = words.length > 0 ? (currentIndex / words.length) * 100 : 0;
        }
        progressBarFill.style.width = `${progress}%`;
    }

    function updateVoiceIndicator() {
        const vs = document.getElementById('voiceSelect');
        const selectedOption = vs.selectedOptions[0];
        const bottomVoice = document.getElementById('bottomVoice');
        if (!selectedOption) { 
          document.getElementById('activeVoiceDisplay').textContent = i18n[curLang].no_voices; 
          if (bottomVoice) bottomVoice.textContent = i18n[curLang].no_voices; 
          return; 
        }
        // If "system" is selected, try to show the resolved best French voice name
        if (selectedOption.value === 'system') {
          const resolved = bestFrenchVoice();
          if (resolved) {
            document.getElementById('activeVoiceDisplay').textContent = `ğŸ—£ï¸ ${resolved.name} (${resolved.lang})`;
            if (bottomVoice) bottomVoice.textContent = `${resolved.name} (${resolved.lang})`;
            return;
          }
        }
        document.getElementById('activeVoiceDisplay').textContent = `ğŸ—£ï¸ ${selectedOption.text}`;
        if (bottomVoice) bottomVoice.textContent = selectedOption.text;
    }

    function getSelectedStudyMode() {
      const sel = document.getElementById('studyModeSelect');
      if (sel) return sel.value;
      // Fallback to legacy radios if present
      const radio = document.querySelector('input[name="studyMode"]:checked');
      return radio ? radio.value : 'listenThenRepeat';
    }

    function updateStudyModeIndicator() {
      const sel = document.getElementById('studyModeSelect');
      const text = (sel && sel.selectedOptions && sel.selectedOptions[0]) ? sel.selectedOptions[0].text : '';
      document.getElementById('activeStudyModeDisplay').textContent = `${i18n[curLang].indicator_mode_prefix} ${text}`;
      const bottomMode = document.getElementById('bottomMode'); if (bottomMode) bottomMode.textContent = text;
    }

    function updateShuffleIndicator() {
      document.getElementById('activeShuffleDisplay').textContent = shuffleEnabled ? i18n[curLang].indicator_shuffle_on : i18n[curLang].indicator_shuffle_off;
      const bottomShuffle = document.getElementById('bottomShuffle');
      if (bottomShuffle) {
        bottomShuffle.textContent = 'ğŸ”€';
        bottomShuffle.classList.toggle('off', !shuffleEnabled);
      }
    }

    function updateAllIndicators() {
      updateVoiceIndicator();
      updateStudyModeIndicator();
      updateShuffleIndicator();
    }
    
    // --- Voice Debug Helper (feature-flagged) ---
    function isVoiceDebugEnabled() {
      try {
        const hash = (location.hash || '').toLowerCase();
        if (hash.includes('voicedebug')) return true;
      } catch (_) {}
      try {
        const params = new URLSearchParams(location.search || '');
        if (params.has('voicedebug')) {
          const val = (params.get('voicedebug') || '').toLowerCase();
          if (val === '' || val === '1' || val === 'true' || val === 'yes') return true;
        }
      } catch (_) {}
      try { return localStorage.getItem('voiceDebug') === '1'; } catch (_) { return false; }
    }

    function ensureVoiceDebugEl() {
      let el = document.getElementById('voiceDebug');
      if (!el) {
        const host = document.getElementById('bottomStatus') || document.body;
        el = document.createElement('div');
        el.id = 'voiceDebug';
        el.className = '';
        el.style.opacity = '0.7';
        el.style.fontSize = '0.85em';
        host.appendChild(el);
      }
      return el;
    }

    function renderVoiceDebug() {
      const enabled = isVoiceDebugEnabled();
      const el = ensureVoiceDebugEl();
      if (!enabled) { el.style.display = 'none'; return; }

      // Gather info
      const all = Array.isArray(availableVoices) ? availableVoices : [];
      const fr = all.filter(v => (v.lang || '').toLowerCase().startsWith('fr'));
      const engine = isSafari ? 'Safari' : (isChromium ? 'Chromium' : (isFirefox ? 'Firefox' : 'Other'));
      const vs = document.getElementById('voiceSelect');
      const selectedVal = (vs && vs.value) ? vs.value : currentVoice || 'system';
      let selectedText = 'System';
      if (vs && vs.selectedOptions && vs.selectedOptions[0]) {
        selectedText = vs.selectedOptions[0].value === 'system' ? 'System' : vs.selectedOptions[0].text;
      } else if (selectedVal && selectedVal !== 'system') {
        const vo = fr.find(v => v.name === selectedVal);
        selectedText = vo ? `${vo.name} (${vo.lang})` : selectedVal;
      }
      const best = bestFrenchVoice();
      const resolvedText = best ? `${best.name} (${best.lang})` : 'â€”';

      el.textContent = `Voice Debug â€” Selected: ${selectedText} | Resolved: ${resolvedText} | Engine: ${engine} | FR: ${fr.length}/${all.length}`;
      el.style.display = 'block';
    }

    // Expose toggles for convenience during testing
    window.enableVoiceDebug = function() { try { localStorage.setItem('voiceDebug', '1'); } catch (_) {} renderVoiceDebug(); };
    window.disableVoiceDebug = function() { try { localStorage.removeItem('voiceDebug'); } catch (_) {} renderVoiceDebug(); };
    
    function generateWordListsUI() {
        const containers = [
          { container: document.getElementById('wordListsOptions'), section: document.getElementById('wordListsSection') },
          { container: document.getElementById('menuWordListsOptions'), section: document.getElementById('menuWordListsSection') },
        ];
        containers.forEach(({container, section}) => { if (container) container.innerHTML = ''; });
        const filenames = Object.keys(wordLists);
        containers.forEach(({container, section}) => {
          if (!container || !section) return;
          if (filenames.length > 1) {
              section.style.display = 'block';
              filenames.forEach(name => {
                  const item = document.createElement('div');
                  item.className = 'mode-option';
                  const checkbox = document.createElement('input');
                  checkbox.type = 'checkbox';
                  checkbox.checked = wordLists[name].enabled;
                  checkbox.id = `file--${name}`;
                  checkbox.dataset.filename = name;
                  checkbox.addEventListener('change', () => {
                      confirmationCallback = () => {
                          wordLists[name].enabled = checkbox.checked;
                          rebuildActiveWordsList();
                      };
                      document.getElementById('confirmationDialogText').textContent = i18n[curLang].confirm_word_list;
                      confirmationDialog.classList.add('visible');
                  });
                  const label = document.createElement('label');
                  label.htmlFor = `file--${name}`;
                  label.textContent = `${name} (${wordLists[name].words.length} ${i18n[curLang].words_lower})`;
                  item.appendChild(checkbox);
                  item.appendChild(label);
                  container.appendChild(item);
              });
          } else {
              section.style.display = 'none';
          }
        });
    }

    function rebuildActiveWordsList() {
        let newWordList = [];
        let fileCount = 0;
        for(const filename in wordLists) {
            if(wordLists[filename].enabled) {
                newWordList = newWordList.concat(wordLists[filename].words);
                fileCount++;
            }
        }
        words = newWordList;
        originalWordOrder = [...words]; // Update original order for unshuffling
        const bottomIcon = document.getElementById('bottomFileStatus');
        if (bottomIcon) {
          if (words.length > 0) {
            bottomIcon.textContent = 'âœ…';
            bottomIcon.classList.remove('status-alert');
            bottomIcon.classList.add('status-ok');
          } else {
            bottomIcon.textContent = 'âŒ';
            bottomIcon.classList.remove('status-ok');
            bottomIcon.classList.add('status-alert');
          }
        }
        // Build articles pools (indef: un/une, def: le/la)
        const indepPattern = /^(un|une)[\s-]+(.+)$/i;
        const defPattern = /^(le|la)[\s-]+(.+)$/i;
        prefixWordsIndef = words
          .map(w => w.trim())
          .filter(Boolean)
          .filter(w => indepPattern.test(w))
          .map(w => { const m = w.match(indepPattern); return { full: w, prefix: m[1].toLowerCase(), base: m[2].trim() }; });
        prefixWordsDef = words
          .map(w => w.trim())
          .filter(Boolean)
          .filter(w => defPattern.test(w))
          .map(w => { const m = w.match(defPattern); return { full: w, prefix: m[1].toLowerCase(), base: m[2].trim() }; });
        window.prefixOriginalOrderIndef = [...prefixWordsIndef];
        window.prefixOriginalOrderDef = [...prefixWordsDef];
        // Enable/disable articles options in dropdown
        const sel = document.getElementById('studyModeSelect');
        if (sel) {
          const hasIndef = prefixWordsIndef.length > 0;
          const hasDef = prefixWordsDef.length > 0;
          const optIndef = sel.querySelector('option[value="articlesIndef"]');
          const optDef = sel.querySelector('option[value="articlesDef"]');
          if (optIndef) optIndef.disabled = !hasIndef;
          if (optDef) optDef.disabled = !hasDef;
          if (sel.value === 'articlesIndef' && !hasIndef) sel.value = 'listenThenRepeat';
          if (sel.value === 'articlesDef' && !hasDef) sel.value = 'listenThenRepeat';
        }
        initializeStudy();
    }

    function showToast(message, duration = 3000) {
        toastNotification.textContent = message;
        toastNotification.classList.add('visible');
        setTimeout(() => {
            toastNotification.classList.remove('visible');
        }, duration);
    }

    function updateDisplayUpper(t, isComplete = false) { 
        const el = document.getElementById("displayAreaUpper");
        el.textContent = t;
        el.classList.toggle('session-complete-message', isComplete);
    }
    function updateInstruction(t='') {
        const el = document.getElementById('displayInstruction');
        if (el) el.textContent = t || '';
    }
    function updateStatusInfo(m) { 
        const el = document.getElementById("statusInfo");
        if (!el) return;
        // Do not print the generic ready/empty prompts; keep bottom bar compact
        if (!m || m === i18n[curLang].ready_to_start || m === i18n[curLang].status_load_prompt) {
          el.textContent = '';
          return;
        }
        el.textContent = m; 
        el.classList.remove('status-ok','status-alert');
    }
    
    // --- EVENT LISTENERS ---
    // Modals
    function primeVoices() {
      try {
        const u = new SpeechSynthesisUtterance(' ');
        u.lang = 'fr-FR';
        u.volume = 0; // silent
        u.rate = 0.1;
        u.onend = () => setTimeout(populateVoiceList, 0);
        synth.speak(u);
      } catch (_) { /* no-op */ }
    }

    document.getElementById('settingsBtn').addEventListener('click', () => { 
      // Open Menu for one-click access to controls
      menuModal.classList.add('visible');
      document.getElementById('menuBtn')?.setAttribute('aria-expanded','true');
      if (isSafari) primeVoices();
      populateVoiceList();
      const mc = menuModal.querySelector('.modal-content'); if (mc) mc.focus();
    });
    // Language flags
    const langEnEl = document.getElementById('langEn');
    const langFrEl = document.getElementById('langFr');
    if (langEnEl) langEnEl.addEventListener('click', () => setLanguage('en'));
    if (langFrEl) langFrEl.addEventListener('click', () => setLanguage('fr'));

    // Primary controls
    if (nextBtn) nextBtn.addEventListener('click', () => { if (!nextBtn.disabled) nextWord(); });
    if (repeatBtn) repeatBtn.addEventListener('click', () => { if (!repeatBtn.disabled) repeatWord(); });
    if (showBtn) showBtn.addEventListener('click', () => { if (!showBtn.disabled) showCurrentWord(); });
    if (voiceBtn) voiceBtn.addEventListener('click', () => { if (!voiceBtn.disabled) toggleVoice(); });
    document.getElementById('helpBtn').addEventListener('click', () => { helpModal.classList.add('visible'); const mc = helpModal.querySelector('.modal-content'); if (mc) mc.focus(); });
    // Hamburger menu
    const menuModal = document.getElementById('menuModal');
    const menuBtn = document.getElementById('menuBtn');
    if (menuBtn) menuBtn.addEventListener('click', () => { 
      if (menuModal) { 
        menuModal.classList.add('visible'); 
        menuBtn.setAttribute('aria-expanded','true'); 
        bodyScrollLock(true);
        const closeOverlay = document.getElementById('menuCloseOverlay');
        if (closeOverlay) {
          const rect = menuBtn.getBoundingClientRect();
          closeOverlay.style.top = `${rect.top}px`;
          closeOverlay.style.left = `${rect.left}px`;
          closeOverlay.style.width = `${rect.width}px`;
          closeOverlay.style.height = `${rect.height}px`;
          closeOverlay.style.display = 'block';
        }
        openMenuPanel({ target: menuBtn });
        const mc = menuModal.querySelector('.modal-content'); if (mc) mc.focus(); 
      }
    });
    const menuCloseOverlay = document.getElementById('menuCloseOverlay');
    if (menuCloseOverlay) menuCloseOverlay.addEventListener('click', () => { 
      menuModal.classList.remove('visible'); 
      menuBtn.setAttribute('aria-expanded','false'); 
      menuCloseOverlay.style.display = 'none';
      const mp = document.getElementById('menuPanel'); if (mp) mp.setAttribute('aria-hidden','true');
      bodyScrollLock(false);
    });
    const menuLangEn = document.getElementById('menuLangEn');
    const menuLangFr = document.getElementById('menuLangFr');
    if (menuLangEn) menuLangEn.addEventListener('click', () => { setLanguage('en'); });
    if (menuLangFr) menuLangFr.addEventListener('click', () => { setLanguage('fr'); });
    const menuHelpBtn = document.getElementById('menuHelpBtn');
    if (menuHelpBtn) menuHelpBtn.addEventListener('click', () => { menuModal.classList.remove('visible'); helpModal.classList.add('visible'); const mc = helpModal.querySelector('.modal-content'); if (mc) mc.focus(); });
    const menuSettingsBtn = document.getElementById('menuSettingsBtn');
    if (menuSettingsBtn) menuSettingsBtn.addEventListener('click', () => { menuModal.classList.remove('visible'); settingsModal.classList.add('visible'); if (isSafari) primeVoices(); populateVoiceList(); const mc = settingsModal.querySelector('.modal-content'); if (mc) mc.focus(); });
    // Left-rail expanding panel behavior
    const menuPanel = document.getElementById('menuPanel');
    let menuLastTrigger = null;
    function isReducedMotion() { return window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches; }
    function bodyScrollLock(on) { document.body.style.overflow = on ? 'hidden' : ''; }
    function getFocusableElements(root) { return Array.from(root.querySelectorAll('a, button, input, select, textarea, [tabindex]:not([tabindex="-1"])')).filter(el => !el.disabled && el.offsetParent !== null); }
    function openMenuPanel(trigger) {
      if (!menuPanel) return;
      if (trigger && trigger.target) menuLastTrigger = trigger.target;
      menuPanel.setAttribute('aria-hidden','false');
      const els = getFocusableElements(menuPanel);
      if (els[0]) els[0].focus();
    }
    function closeMenuPanel() {
      if (!menuPanel) return;
      menuPanel.setAttribute('aria-hidden','true');
      if (menuLastTrigger && typeof menuLastTrigger.focus === 'function') menuLastTrigger.focus();
    }
    function toggleMenuPanel() {
      if (!menuPanel) return;
      const open = menuPanel.getAttribute('aria-hidden') === 'false';
      if (open) closeMenuPanel(); else openMenuPanel();
    }
    // Directly open the panel (no rail)
    const menuPanelClose = menuPanel ? menuPanel.querySelector('.close-btn') : null;
    if (menuPanelClose) menuPanelClose.addEventListener('click', closeMenuPanel);
    // Alt+M shortcut
    document.addEventListener('keydown', e => {
      if (e.altKey && (e.key === 'm' || e.key === 'M')) { e.preventDefault(); if (!menuModal.classList.contains('visible')) { menuModal.classList.add('visible'); menuBtn?.setAttribute('aria-expanded','true'); bodyScrollLock(true); openMenuPanel(); } else { toggleMenuPanel(); } }
    });
    
    historyBtn.addEventListener('click', () => {
        historyModalContent.innerHTML = ""; // Clear previous content
        if (displayHistory.length === 0) {
            historyModalContent.textContent = i18n[curLang].history_empty;
        } else {
            displayHistory.forEach(item => {
                const historyItem = document.createElement("div");
                historyItem.className = "history-item";
                historyItem.textContent = item;
                historyModalContent.appendChild(historyItem);
            });
        }
        historyModal.classList.add('visible');
        const mc = historyModal.querySelector('.modal-content'); if (mc) mc.focus();
    });

    const wordListContent = document.getElementById("wordListContent");
    document.getElementById('viewListBtn').addEventListener('click', () => {
        wordListContent.innerHTML = "";
        words.forEach((word, index) => {
            const wordItem = document.createElement("div");
            wordItem.className = "history-item";
            wordItem.textContent = `${index + 1}. ${word}`;
            if (index === currentIndex - 1) wordItem.style.fontWeight = "bold";
            wordListContent.appendChild(wordItem);
        });
        wordListModal.classList.add('visible');
        const mc2 = wordListModal.querySelector('.modal-content'); if (mc2) mc2.focus();
    });
    
    // Confirmation Dialog & Shuffle Logic
    document.getElementById('shuffleToggle').addEventListener('change', e => {
        e.preventDefault();
        confirmationCallback = () => {
            shuffleEnabled = !shuffleEnabled; 
            document.getElementById('shuffleToggle').checked = shuffleEnabled;
            if (shuffleEnabled) {
              shuffleArray(words);
              if (prefixWords.length > 0) shuffleArray(prefixWords);
            } else {
              words = [...originalWordOrder];
              if (window.prefixOriginalOrder) prefixWords = [...window.prefixOriginalOrder];
            }
            updateShuffleIndicator();
            initializeStudy();
        };
        document.getElementById('confirmationDialogText').textContent = i18n[curLang].confirm_shuffle;
        confirmationDialog.classList.add('visible');
    });

    document.getElementById('confirmReset').addEventListener('click', () => {
        if (confirmationCallback) confirmationCallback();
        confirmationDialog.classList.remove('visible');
        confirmationCallback = null;
    });
    document.getElementById('cancelReset').addEventListener('click', () => {
        // Revert UI change if action is cancelled
        generateWordListsUI();
        document.getElementById('shuffleToggle').checked = shuffleEnabled;
        confirmationDialog.classList.remove('visible');
        confirmationCallback = null;
    });

    // File Loading
    const fileInput = document.createElement('input');
    fileInput.type = 'file'; fileInput.accept = '.txt'; fileInput.multiple = true;
    
    fileInput.addEventListener('change', e => {
      if (e.target.files && e.target.files.length > 0) {
        handleFileLoad(Array.from(e.target.files));
      }
    });

    if (!isIOS) {
      document.getElementById('welcomeBrowseBtn').addEventListener('click', () => fileInput.click());
      document.getElementById('welcomeUploadArea').addEventListener('click', () => fileInput.click());
    } else {
      const iosPickerRow = document.getElementById('iosFilePickerRow');
      const iosFileInput = document.getElementById('iosFileInput');
      if (iosPickerRow) iosPickerRow.style.display = 'block';
      if (iosFileInput) {
        iosFileInput.addEventListener('change', e => {
          if (e.target.files && e.target.files.length > 0) {
            handleFileLoad(Array.from(e.target.files));
          }
        });
      }
    }
    function isFileDrag(e) {
      try {
        if (!e.dataTransfer) return false;
        if (e.dataTransfer.files && e.dataTransfer.files.length) return true;
        if (e.dataTransfer.types && typeof e.dataTransfer.types.includes === 'function') {
          return e.dataTransfer.types.includes('Files');
        }
      } catch (_) { }
      return false;
    }
    document.body.addEventListener("dragover", e => { if (isFileDrag(e)) { e.preventDefault(); e.stopPropagation(); } });
    document.body.addEventListener("drop", e => {
      if (!isFileDrag(e)) return;
      e.preventDefault(); e.stopPropagation();
      const files = Array.from(e.dataTransfer.files).filter(f => f.name.endsWith('.txt'));
      if (files.length > 0) handleFileLoad(files);
    });
    // Menu file input handler
    (function(){
      const menuFileInput = document.getElementById('menuFileInput');
      if (menuFileInput) menuFileInput.addEventListener('change', (e) => {
        const files = Array.from(e.target.files || []).filter(f => f.name.endsWith('.txt'));
        if (files.length > 0) handleFileLoad(files);
        e.target.value = '';
      });
    })();
    
    document.getElementById('historyToggleBtn').addEventListener('click', () => document.querySelector('.container').classList.toggle('history-hidden'));

    // Keyboard Shortcuts & Modal Closing
    document.addEventListener("keydown", e => {
      if (e.key === 'Escape') { 
        allModals.forEach(modal => modal.classList.remove('visible'));
        document.getElementById('menuBtn')?.setAttribute('aria-expanded','false');
        const mco = document.getElementById('menuCloseOverlay'); if (mco) mco.style.display = 'none';
        const mp = document.getElementById('menuPanel'); if (mp) mp.setAttribute('aria-hidden','true');
        bodyScrollLock(false);
      }
      if (e.target.tagName.toLowerCase() === 'input' || document.querySelector('.modal.visible')) return;
      const btnId = { ' ': 'nextBtn', 'r': 'repeatBtn', 's': 'showBtn', 'v': 'voiceBtn' }[e.key.toLowerCase()];
      if (btnId && !e.metaKey && !e.ctrlKey && !e.altKey) {
        e.preventDefault();
        const btn = document.getElementById(btnId);
        if(btn && !btn.disabled) btn.click();
      }
    });
    
    allModals.forEach(modal => {
        modal.addEventListener('click', e => { 
          if (e.target === modal) { 
            modal.classList.remove('visible'); 
            if (modal.id === 'menuModal') { 
              document.getElementById('menuBtn')?.setAttribute('aria-expanded','false');
              const mco = document.getElementById('menuCloseOverlay'); if (mco) mco.style.display = 'none';
              // Ensure panel is reset and scrolling unlocked
              const mp = document.getElementById('menuPanel'); if (mp) mp.setAttribute('aria-hidden','true');
              bodyScrollLock(false);
            }
          }
        });
        const closeBtn = modal.querySelector('.close-btn');
        if(closeBtn) closeBtn.addEventListener('click', () => { 
          modal.classList.remove('visible'); 
          if (modal.id === 'menuModal') { 
            document.getElementById('menuBtn')?.setAttribute('aria-expanded','false');
            const mco = document.getElementById('menuCloseOverlay'); if (mco) mco.style.display = 'none';
            const mp = document.getElementById('menuPanel'); if (mp) mp.setAttribute('aria-hidden','true');
            bodyScrollLock(false);
          }
        });
    });
    // Articles/Privative controls handlers
    const unBtn = document.getElementById('prefixUnBtn');
    const uneBtn = document.getElementById('prefixUneBtn');
    if (unBtn) unBtn.addEventListener('click', () => {
      if (!currentBaseWord) return;
      const mode = getSelectedStudyMode();
      const choice = (mode === 'articlesDef') ? 'le' : 'un';
      const correct = currentExpectedPrefix === choice;
      const msg = (correct ? i18n[curLang].toast_correct_prefix : i18n[curLang].toast_wrong_prefix)
        .replace('{prefix}', currentExpectedPrefix)
        .replace('{base}', currentBaseWord);
      showToast(msg);
      updateDisplayUpper(`${currentExpectedPrefix} ${currentBaseWord}`);
      addToHistory(`${currentExpectedPrefix} ${currentBaseWord}`);
      // Speak the full phrase after answer provided
      speakWord(`${currentExpectedPrefix} ${currentBaseWord}`);
      privativeAnswered = true;
    });
    if (uneBtn) uneBtn.addEventListener('click', () => {
      if (!currentBaseWord) return;
      const mode = getSelectedStudyMode();
      const choice = (mode === 'articlesDef') ? 'la' : 'une';
      const correct = currentExpectedPrefix === choice;
      const msg = (correct ? i18n[curLang].toast_correct_prefix : i18n[curLang].toast_wrong_prefix)
        .replace('{prefix}', currentExpectedPrefix)
        .replace('{base}', currentBaseWord);
      showToast(msg);
      updateDisplayUpper(`${currentExpectedPrefix} ${currentBaseWord}`);
      addToHistory(`${currentExpectedPrefix} ${currentBaseWord}`);
      // Speak the full phrase after answer provided
      speakWord(`${currentExpectedPrefix} ${currentBaseWord}`);
      privativeAnswered = true;
    });
    
    document.getElementById('voiceSelect').addEventListener('change', e => { 
      currentVoice = e.target.value; 
      try { localStorage.setItem('selectedVoice', currentVoice); } catch (_) {}
      updateVoiceIndicator(); 
      renderVoiceDebug();
    });
    document.getElementById('voiceSelect').addEventListener('focus', populateVoiceList);
    const voiceTestBtn = document.getElementById('voiceTestBtn');
    if (voiceTestBtn) voiceTestBtn.addEventListener('click', () => { speakWord(i18n[curLang].test_phrase); });
    const studyModeSelect = document.getElementById('studyModeSelect');
    if (studyModeSelect) studyModeSelect.addEventListener('change', () => {
      updateStudyModeIndicator();
      const isArticles = (getSelectedStudyMode() === 'articlesIndef' || getSelectedStudyMode() === 'articlesDef');
      document.getElementById('privativeControls').style.display = isArticles ? 'flex' : 'none';
      // Update prefix buttons for selected articles mode
      const unBtnLbl = document.getElementById('prefixUnBtn');
      const uneBtnLbl = document.getElementById('prefixUneBtn');
      if (unBtnLbl && uneBtnLbl) {
        if (getSelectedStudyMode() === 'articlesDef') { unBtnLbl.textContent = i18n[curLang].btn_prefix_le || 'Prefix: le'; uneBtnLbl.textContent = i18n[curLang].btn_prefix_la || 'Prefix: la'; }
        else { unBtnLbl.textContent = i18n[curLang].btn_prefix_un; uneBtnLbl.textContent = i18n[curLang].btn_prefix_une; }
      }
      updateProgressBar();
      try { localStorage.setItem('studyMode', studyModeSelect.value); } catch (_) {}
    });

    // --- INITIALIZATION ---
    document.addEventListener('DOMContentLoaded', () => {
        // Restore preferences
        try {
          const savedVoice = localStorage.getItem('selectedVoice');
          if (savedVoice) currentVoice = savedVoice;
        } catch (_) {}
        try {
          const savedMode = localStorage.getItem('studyMode');
          const validModes = new Set(['listenRead','readThenSay','listenThenRepeat','articlesDef','articlesIndef']);
          const fallback = 'listenThenRepeat';
          const modeToUse = validModes.has(savedMode) ? savedMode : fallback;
          const sel = document.getElementById('studyModeSelect');
          if (sel) sel.value = modeToUse;
        } catch (_) {}

        populateVoiceList(); // Use the (restored) currentVoice where possible
        setLanguage("en");
        updateAllIndicators();
        welcomeModal.classList.add('visible');
        // Initialize voice debug if enabled
        renderVoiceDebug();
        // Apply iOS-only layout tweaks
        if (isIOS) { document.body.classList.add('is-ios'); document.documentElement.classList.add('is-ios'); }
        // Adjust welcome area text for iOS
        if (isIOS) {
          const dd = document.querySelector('#welcomeUploadArea h3');
          const orP = document.querySelector('#welcomeUploadArea p');
          const browseBtn = document.getElementById('welcomeBrowseBtn');
          if (dd) dd.textContent = 'Select .txt files';
          if (orP) orP.style.display = 'none';
          if (browseBtn) browseBtn.style.display = 'none';
        }
        // Initialize articles controls visibility on load
        document.getElementById('privativeControls').style.display = (getSelectedStudyMode() === 'articlesIndef' || getSelectedStudyMode() === 'articlesDef') ? 'flex' : 'none';
        // Show iOS-specific voice hint
        try {
          const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (/Macintosh/.test(navigator.userAgent) && 'ontouchend' in document);
          const hint = document.getElementById('iosVoiceHint');
          if (hint && isIOS) hint.style.display = 'block';
        } catch (_) {}
        
        // Version labels
        // Set version displays
        const verCorner = document.getElementById('appVersionCorner');
        const verWelcome = document.getElementById('welcomeVersion');
        const verMenu = document.getElementById('menuVersion');
        const verBottom = document.getElementById('bottomVersion');
        if (verCorner) verCorner.textContent = APP_VERSION;
        if (verWelcome) verWelcome.textContent = APP_VERSION;
        if (verMenu) verMenu.textContent = APP_VERSION;
        if (verBottom) verBottom.textContent = APP_VERSION;

        // Inline handlers are used for control buttons and language flags
    });
  </script>
</body>
</html>
