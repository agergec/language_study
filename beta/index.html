<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover"/>
  <!-- PWA: iOS standalone support -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="French Study">
  <meta name="theme-color" content="#4A90E2">
  <!-- Manifest will be injected from inline JSON via Blob at runtime -->
  <link rel="manifest" id="manifestLink">
  <!-- iOS home-screen icon (set at runtime to PNG) -->
  <link rel="apple-touch-icon" sizes="180x180" id="appleIcon">
  <title data-i18n="page_title">üá´üá∑ French Listening Study</title>

  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üá´üá∑</text></svg>">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&display=swap" rel="stylesheet">

  <style>
    /* --- CSS Reset & Variables --- */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      --primary-color: #4A90E2;
      --success-color: #50E3C2;
      --warning-color: #F5A623;
      --secondary-color: #B8E986;
      --text-color: #4A4A4A;
      --light-gray: #F7F7F7;
      --border-color: #EAEAEA;
      --background-color: #FFFFFF;
      --font-family: 'Nunito', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      --border-radius: 12px;
      --shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    }

    /* --- Base Layout (Viewport App) --- */
    html, body {
      height: 100vh;
      width: 100vw;
      overflow: hidden;
      font-family: var(--font-family);
      background-color: var(--light-gray);
      color: var(--text-color);
    }

    .container {
      width: 100%;
      height: 100%;
      min-height: 100svh;
      display: grid;
      grid-template-rows: auto auto 1fr auto auto;
      grid-template-columns: 1fr;
      grid-template-areas: "header" "sub-header" "display" "controls" "footer";
      padding: 0.75rem;
      gap: 0.75rem;
    }

    /* --- Desktop Layout --- */
    @media (min-width: 1024px) and (min-height: 600px) {
      .container {
        grid-template-rows: auto auto 1fr auto;
        grid-template-columns: 280px 1fr 200px;
        grid-template-areas: "header header header" "sub-header sub-header sub-header" "history display controls" "footer footer footer";
        padding: 1.5rem;
        gap: 1.5rem;
      }
      .container.history-hidden { grid-template-columns: 40px 1fr 200px; }
    }

    /* --- Header, Sub-header & Progress Bar --- */
    .header { grid-area: header; display: flex; flex-direction: column; gap: 0.75rem; }
    .header-top { display: flex; justify-content: space-between; align-items: center; }
    .header h1 { font-size: 1.25em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .header-actions { display: flex; align-items: center; gap: 1rem; flex-shrink: 0; }
    .icon-btn { background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--text-color); transition: transform 0.2s; }
    .icon-btn:hover { transform: scale(1.1); }
    .language-flags { display: flex; gap: 0.5rem; }
    .language-flag { font-size: 1.5rem; cursor: pointer; opacity: 0.5; transition: all 0.2s ease; background: none; border: none; padding: 0; line-height: 1; }
    .language-flag.active { opacity: 1; transform: scale(1.15); }
    /* Always use hamburger; hide individual icons/flags on main header */
    .header-actions .icon-btn:not(#menuBtn), .header-actions .language-flags { display: none; }
    
    .progress-bar { width: 100%; height: 5px; background-color: var(--border-color); border-radius: 5px; overflow: hidden; }
    .progress-bar-fill { height: 100%; width: 0%; background-color: var(--success-color); transition: width 0.3s ease-in-out; border-radius: 5px; }

    /* Hide old top status strip; we move indicators to footer */
    .sub-header { display: none; }
    .status-indicator { background-color: var(--light-gray); padding: 0.25rem 0.75rem; border-radius: 1rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100%; }

    /* --- Main Display --- */
    .display-container { grid-area: display; background: var(--primary-color); color: white; border-radius: var(--border-radius); display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1rem; position: relative; overflow: hidden; box-shadow: var(--shadow); }
    .display-area-upper { font-size: clamp(2rem, 8vw, 4.5rem); font-weight: 800; text-align: center; }
    .display-instruction { margin-top: 0.5rem; font-size: clamp(0.9rem, 2.5vw, 1rem); opacity: 0.9; text-align: center; }
    .session-complete-message { font-size: clamp(1.5rem, 5vw, 2.5rem); opacity: 0.9; }

    /* --- Controls --- */
    .controls-vertical { grid-area: controls; display: flex; flex-direction: column; gap: 0.75rem; }
    @media (max-width: 1023px) { .controls-vertical { flex-direction: row; flex-wrap: wrap; } }
    .btn { padding: 0.75rem 1rem; border: none; border-radius: 8px; cursor: pointer; font-size: 1rem; font-weight: 700; transition: all .2s ease; color: white; text-align: center; }
    @media (max-width: 1023px) { .btn { flex-grow: 1; min-width: 120px; } }
    .btn:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15); }
    .btn:disabled { background-color: #ccc; cursor: not-allowed; transform: none; box-shadow: none; }
    .btn-primary { background-color: var(--primary-color); }
    .btn-secondary { background-color: var(--secondary-color); color: var(--text-color); }
    /* Ensure Repeat button matches other buttons' text color */
    #repeatBtn { color: #fff; }
    .btn-success { background-color: var(--success-color); }
    .btn-warning { background-color: var(--warning-color); }
    .btn-info { background-color: #90b8de; }

    /* --- History Sidebar --- */
    .history-sidebar { grid-area: history; display: none; flex-direction: column; background: var(--background-color); border-radius: var(--border-radius); box-shadow: var(--shadow); padding: 1rem; overflow: hidden; transition: all 0.3s ease-in-out; }
    @media (min-width: 1024px) and (min-height: 600px) { .history-sidebar { display: flex; } }
    .history-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; flex-shrink: 0; }
    .history-title { font-weight: bold; border-bottom: 1px solid var(--border-color); padding-bottom: 0.5rem; flex-grow: 1; }
    #historyToggleBtn { margin-left: 0.5rem; transform: rotate(0deg); transition: transform 0.3s; }
    .history-list { flex-grow: 1; overflow-y: auto; padding-right: 0.5rem; }
    .history-item { padding: 0.25rem 0.5rem; border-radius: 4px; }
    .history-item:nth-child(even) { background-color: var(--light-gray); }

    .container.history-hidden .history-sidebar { padding: 1rem 0; }
    .container.history-hidden .history-title,
    .container.history-hidden .history-list { display: none; }
    .container.history-hidden #historyToggleBtn { transform: rotate(180deg); }

    /* --- Countdown --- */
    .countdown-wrapper { position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%); display: none; flex-direction: column; align-items: center; justify-content: center; min-height: 60px; pointer-events: none; top: auto; }
    .progress-ring { position: relative; width: 60px; height: 60px; }
    .progress-ring__circle { transition: stroke-dashoffset 0.1s linear; transform: rotate(-90deg); transform-origin: 50% 50%; stroke-width: 6; stroke: var(--success-color); stroke-linecap: round; }
    .progress-ring__track { stroke-width: 6; stroke: var(--border-color); }
    .countdown-text { font-size: 1.5rem; font-weight: 700; color: var(--primary-color); }

    /* --- Footer / Status Bar --- */
    .footer { grid-area: footer; display: flex; flex-direction: column; gap: 0.35rem; padding-top: 0.5rem; border-top: 1px solid var(--border-color); font-size: 0.85em; }
    .footer-meta { display: flex; justify-content: space-between; align-items: center; gap: 1rem; }
    #statusInfo { display: none; }
    .bottom-status { display: flex; align-items: center; justify-content: space-between; color: #666; overflow: hidden; }
    .bottom-left { display: flex; align-items: center; gap: 0.5rem; flex: 1; min-width: 0; }
    .bottom-status .sep { opacity: 0.4; }
    .bottom-status .off { opacity: 0.3; filter: grayscale(1); }
    .bottom-status span { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    #bottomVoice, #bottomMode { min-width: 0; }
    /* Allow mode to wrap on small screens to avoid horizontal scroll */
    #bottomMode { flex: 1; white-space: normal; overflow-wrap: anywhere; word-break: break-word; line-height: 1.15; }
    /* Slightly smaller font for wrapped mode names on narrow screens */
    @media (max-width: 480px) { #bottomMode { font-size: 0.9em; } }
    .bottom-version { display: none; color: #666; }
    @media (min-width: 1024px) { .bottom-version { display: inline; } }
    /* no spacer row; display grows naturally */
    .status-ok { color: #2e7d32; }
    .status-alert { color: #c62828; }

    /* --- Modals --- */
    .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(40, 40, 40, 0.55); align-items: center; justify-content: center; backdrop-filter: blur(8px); overflow-y: auto; -webkit-overflow-scrolling: touch; }
    .modal.visible { display: flex; }
    .modal-content { background-color: var(--background-color); padding: 1.5rem; border-radius: var(--border-radius); width: 90%; max-width: 500px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); max-height: 80vh; overflow-y: auto; }
    html.is-ios .modal { align-items: flex-start; padding: 1rem; }
    html.is-ios .modal-content { max-height: calc(100svh - 2rem); -webkit-overflow-scrolling: touch; }
    html.is-standalone .modal { align-items: flex-start; padding: 1rem; padding-top: calc(1rem + env(safe-area-inset-top)); }
    html.is-standalone .modal-content { max-height: calc(100svh - (1rem + env(safe-area-inset-top)) - 1rem); }
    .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; border-bottom: 1px solid var(--border-color); padding-bottom: 0.5rem; }
    .modal-header h2 { margin: 0; }
    .modal-section { margin-bottom: 1rem; border-bottom: 1px solid var(--border-color); padding-bottom: 1rem; }
    .modal-section:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0;}
    .modal-section label { font-weight: 600; display: block; margin-bottom: 0.5rem; }
    .mode-options, .word-lists-options { display: flex; flex-direction: column; gap: 0.75rem; }
    .mode-option { display: flex; align-items: center; gap: 0.5rem; }
    .close-btn { font-size: 1.5rem; }
    #welcomeModal .modal-content { text-align: center; }
    #welcomeUploadArea { padding: 2rem; border: 3px dashed var(--primary-color); border-radius: var(--border-radius); cursor: pointer; background-color: var(--light-gray); }
    #welcomeUploadArea:hover { background-color: #eaf2fa; }
    
    .word-list { max-height: 60vh; overflow-y: auto; }

    /* --- Toast Notification --- */
    .toast {
      position: fixed;
      bottom: -100px;
      left: 50%;
      transform: translateX(-50%);
      padding: 1rem 1.5rem;
      background-color: var(--text-color);
      color: white;
      border-radius: var(--border-radius);
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      transition: bottom 0.5s ease-in-out;
      z-index: 2000;
      font-weight: 600;
    }
    .toast.visible {
      bottom: 20px;
    }
    /* iOS Safari adjustments: allow scroll and safe-area padding only on iOS */
    html.is-ios, body.is-ios {
      height: auto;
      min-height: 100svh;
      width: 100%;
      overflow-x: hidden;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }
    body.is-ios .container {
      height: auto;
      min-height: 100svh;
      padding-top: calc(0.75rem + env(safe-area-inset-top));
      padding-bottom: calc(0.75rem + env(safe-area-inset-bottom));
    }
    /* Standalone (PWA) safe-area padding */
    html.is-standalone .container { padding-top: calc(0.75rem + env(safe-area-inset-top)); padding-bottom: calc(0.75rem + env(safe-area-inset-bottom)); }
    /* App version tags */
    .app-version-corner { display: none; }

    /* iOS adjustments: (countdown circle removed) restore default padding */
    html.is-ios .display-container { padding-bottom: 1rem; }
    html.is-ios .countdown-wrapper { bottom: calc(12px + env(safe-area-inset-bottom)); }

    /* Right-Side Drawer Menu (cross-browser) */
    /* Make the modal act as a backdrop with a right-aligned drawer. */
    #menuModal { align-items: stretch; justify-content: flex-end; z-index: 2500; overflow: hidden; }
    #menuModal .modal-content {
      position: relative;
      width: min(560px, 92vw);
      height: 100vh;
      margin: 0;
      border-radius: 0;
      background: var(--background-color);
      box-shadow: -12px 0 28px rgba(0,0,0,0.2);
      border: 0;
      display: block;
      padding: 0;
      overflow: hidden; /* internal panels handle their own scrolling */
      transform: translateX(100%);
      transition: transform 220ms cubic-bezier(.2,.8,.2,1);
      will-change: transform;
    }
    #menuModal.visible .modal-content { transform: translateX(0); }
    #menuModal .menu-shell { position: relative; height: 100%; }
    /* Panels live inside the drawer; slide subpanels horizontally */
    #menuModal .panel {
      position: absolute;
      inset: 0;
      background: var(--background-color);
      transform: translateX(0);
      transition: transform 220ms cubic-bezier(.2,.8,.2,1);
    }
    #menuModal .panel[aria-hidden="true"] { pointer-events: none; }
    #menuModal .panel[aria-hidden="false"] { pointer-events: auto; }
    @media (prefers-reduced-motion: reduce) { #menuModal .panel, #menuModal .modal-content { transition-duration: 1ms; } }
    #menuModal .panel-header { display: flex; align-items: center; justify-content: space-between; padding: 0.75rem 1rem; border-bottom: 1px solid var(--border-color); }
    #menuModal .panel-body { padding: 1rem; height: calc(100% - 56px); overflow: auto; background: #f2f2f7; }
    #menuModal .modal-header { display:none; }
    #menuModal .modal-section { border: none; padding-bottom: 0; margin-bottom: 0.75rem; }
    #menuModal .menu-list button { display: block; width: 100%; text-align: left; padding: 0.75rem 0; background: none; border: none; font-size: 1rem; font-weight: 700; color: var(--text-color); }
    #menuModal hr { border: 0; border-top: 1px solid var(--border-color); margin: 0.5rem 0; }
    #menuModal .menu-field { display: flex; flex-direction: column; gap: 0.35rem; padding: 0.5rem 0; }
    #menuModal .menu-field .label-row { display:flex; align-items:center; gap:.5rem; }
    #menuModal .menu-field label { font-weight: 700; font-size: 0.9rem; }
    #menuModal .switch-row { display: flex; align-items: center; gap: 0.5rem; }
    #menuModal .menu-icon { width: 1.2rem; text-align:center; opacity:.7; }
    #menuModal hr.menu-divider { border: 0; border-top: 1px solid var(--border-color); margin: 0.75rem 0; opacity: .7; }
    .version-inline {
      margin-top: 0.5rem;
      color: #666;
      font-size: 0.85em;
    }

    /* Floating close button (aligned with hamburger) */
    #menuCloseOverlay {
      position: fixed;
      z-index: 1500; /* above drawer */
      display: none;
      background: transparent;
      border: none;
      font-size: 1.75rem;
      color: var(--text-color);
      line-height: 1;
      touch-action: manipulation;
    }
    /* Prefer floating close on mobile */
    @media (max-width: 1023px) { #menuModal .modal-header .close-btn { display: none; } }

    /* Thin red countdown bar at top of main display */
    .countdown-topbar { position: absolute; top: 0; left: 0; right: 0; height: 3px; background: rgba(255,255,255,0.25); }
    .countdown-topbar-fill { height: 100%; width: 0%; background: #ff3b30; transition: width 0.1s linear; }
    /* iOS-style grouped Settings mockup */
    .settings-section-title { font-weight: 800; font-size: clamp(0.75rem, 1.6vw, 0.9rem); color: #8e8e93; letter-spacing: .04em; margin: 0.75rem 0 0.5rem; padding-left: .25rem; text-transform: uppercase; }
    .settings-card { background: #fff; border-radius: 14px; overflow: hidden; border: 1px solid rgba(0,0,0,0.06); box-shadow: 0 1px 0 rgba(0,0,0,0.04); }
    .settings-item { position: relative; display: flex; align-items: center; gap: 12px; padding: 14px 16px; border-bottom: 1px solid #ececec; font-size: 1rem; }
    .settings-item:last-child { border-bottom: none; }
    .settings-label { flex: 1; color: #000; }
    .settings-value { color: #8e8e93; margin-left: auto; }
    .settings-chevron { color: #c7c7cc; margin-left: 8px; font-weight: 700; }
    .settings-danger { color: #ff3b30; font-weight: 700; }
    .settings-footer { color: #8e8e93; font-size: 0.85rem; text-align: center; padding: 0.75rem 0; }
    /* Overlay selects turn rows into native pickers while showing value text */
    .overlay-select { position: absolute; inset: 0; opacity: 0; -webkit-appearance: none; appearance: none; width: 100%; height: 100%; border: none; background: transparent; cursor: pointer; }
    /* iOS switch */
    .ios-switch { -webkit-appearance: none; appearance: none; width: 51px; height: 31px; background: #e9e9ea; border-radius: 999px; position: relative; outline: none; cursor: pointer; transition: background .2s ease; flex: 0 0 auto; }
    .ios-switch::before { content: ''; position: absolute; top: 2px; left: 2px; width: 27px; height: 27px; background: #fff; border-radius: 50%; box-shadow: 0 1px 3px rgba(0,0,0,.25); transition: transform .2s ease; }
    .ios-switch:checked { background: #34c759; }
    .ios-switch:checked::before { transform: translateX(20px); }
    /* Hide legacy holders when grouped mockup is used */
    #legacyMenuContent { display: none; }
    /* Subpanels (push navigation) */
    /* Subpanels slide over the main panel within the drawer */
    #menuModal .subpanel { position: absolute; inset: 0; background: var(--background-color); transform: translateX(100%); transition: transform 220ms cubic-bezier(.2,.8,.2,1); z-index: 2; }
    #menuModal .subpanel[aria-hidden="false"] { transform: translateX(0); }
    #menuModal .subpanel .panel-body { background: #f2f2f7; }
    .panel-back { background: none; border: 0; font-size: 1rem; color: var(--primary-color); padding: 8px; }
    .panel-actions { display:flex; align-items:center; gap: 8px; min-width: 44px; justify-content: flex-end; }
    .panel-link { background: none; border: 0; color: var(--primary-color); font-weight: 700; padding: 6px 8px; font-size: 0.98rem; }
    .panel-link.link-disabled { opacity: .45; pointer-events: none; }
    .settings-check { color: var(--primary-color); font-weight: 800; margin-left: auto; }
    html.is-ios #menuModal .subpanel .panel-header { padding-top: calc(0.75rem + env(safe-area-inset-top)); }
    /* Hide main header when a subpanel is open to avoid overlap */
    #menuPanel.sub-open > .panel-header { visibility: hidden; pointer-events: none; }
    /* Hide subpanel center title (keep breadcrumbs in body) */
    #menuModal .subpanel .panel-header h2 { display: none; }
    /* Subtle text and footer notes */
    .subtle { color: #8e8e93; font-size: 0.9em; }
    .settings-note { color: #8e8e93; font-size: 0.85rem; padding: 0.75rem 0; }
    .btn-destructive { background: none; border: 0; color: #ff3b30; font-weight: 700; padding: 12px 8px; text-align: center; width: 100%; }
    /* Action sheet */
    .sheet-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,.3); display: none; align-items:flex-end; justify-content:center; z-index: 1600; }
    .sheet-backdrop.visible { display:flex; }
    .sheet { width: 100%; max-width: 560px; background: #f2f2f7; padding: 8px; border-radius: 16px 16px 0 0; }
    .sheet .action { background:#fff; border:1px solid rgba(0,0,0,.06); border-radius:12px; padding:14px; text-align:center; margin-bottom:8px; font-weight:600; }
    .sheet .cancel { background:#fff; border-radius:12px; padding:14px; text-align:center; font-weight:600; }
  </style>
</head>
<body>
  <div class="container">
    <header class="header">
      <div class="header-top">
        <h1 data-i18n="header_title">üá´üá∑ French Study</h1>
        <div class="header-actions">
          <button id="helpBtn" class="icon-btn" title="Help" data-i18n-title="title_help">?</button>
          <button id="settingsBtn" class="icon-btn" title="Settings" data-i18n-title="title_settings">‚öôÔ∏è</button>
          <div class="language-flags">
            <button type="button" class="language-flag active" id="langEn" aria-label="English" title="English">üá∫üá∏</button>
            <button type="button" class="language-flag" id="langFr" aria-label="Fran√ßais" title="Fran√ßais">üá´üá∑</button>
          </div>
          <button id="menuBtn" class="icon-btn" aria-label="Settings" title="Settings" aria-controls="menuModal" aria-expanded="false">‚ò∞</button>
        </div>
      </div>
      <div class="progress-bar">
        <div id="progressBarFill" class="progress-bar-fill"></div>
      </div>
    </header>

    <div class="sub-header">
      <div id="activeVoiceDisplay" class="status-indicator"></div>
      <div id="activeStudyModeDisplay" class="status-indicator"></div>
      <div id="activeShuffleDisplay" class="status-indicator"></div>
    </div>

    <aside class="history-sidebar">
      <div class="history-header">
        <div class="history-title" data-i18n="history_title">Answers</div>
        <button id="historyToggleBtn" class="icon-btn" title="Toggle History Panel" data-i18n-title="title_toggle_history">‚Äπ</button>
      </div>
      <div class="history-list" id="historyList"></div>
    </aside>

    <main class="display-container">
      <div class="countdown-topbar"><div id="countdownTopbarFill" class="countdown-topbar-fill"></div></div>
      <div class="display-area-upper" id="displayAreaUpper" data-i18n="welcome_message" aria-live="polite" aria-atomic="true">Welcome!</div>
      <div id="displayInstruction" class="display-instruction"></div>
      <div class="countdown-wrapper">
        <svg class="progress-ring" viewBox="0 0 100 100">
          <circle class="progress-ring__track" cx="50" cy="50" r="45" fill="transparent" />
          <circle class="progress-ring__circle" cx="50" cy="50" r="45" fill="transparent" />
        </svg>
        <span id="countdownText" class="countdown-text">--</span>
      </div>
    </main>

    <aside class="controls-vertical">
      <button class="btn btn-primary" id="nextBtn" disabled data-i18n="btn_next">Next (Space)</button>
      <button class="btn btn-secondary" id="repeatBtn" disabled data-i18n="btn_repeat">Repeat (R)</button>
      <button class="btn btn-success" id="showBtn" disabled data-i18n="btn_show">Show (S)</button>
      <button class="btn btn-warning" id="voiceBtn" disabled data-i18n="btn_toggleVoice">Voice (V)</button>
      <button class="btn btn-info" id="viewListBtn" disabled data-i18n="btn_view_list">View List</button>
      <button class="btn btn-info" id="historyBtn" disabled data-i18n="btn_history">History</button>
      <div id="privativeControls" style="display:none; gap:0.5rem; flex-wrap:wrap;">
        <button class="btn btn-secondary" id="prefixUnBtn" type="button" data-i18n="btn_prefix_un">Prefix: un</button>
        <button class="btn btn-secondary" id="prefixUneBtn" type="button" data-i18n="btn_prefix_une">Prefix: une</button>
      </div>
    </aside>

    <!-- countdown moved into display container -->

    <footer class="footer">
      <div id="bottomStatus" class="bottom-status">
        <div class="bottom-left">
          <span id="bottomShuffle" aria-label="Shuffle" title="Shuffle">üîÄ</span>
          <span class="sep">|</span>
          <span id="bottomFileStatus" class="file-status-icon" aria-label="Files" title="Files">‚ùå</span>
          <span class="sep">|</span>
          <span id="bottomVoice"></span>
          <span class="sep">|</span>
          <span id="bottomMode"></span>
          <span id="statusInfo" class="status-alert" data-i18n="status_load_prompt" aria-live="polite" aria-atomic="true"></span>
        </div>
        <span id="bottomVersion" class="bottom-version"></span>
      </div>
    </footer>
  </div>

  <div id="welcomeModal" class="modal">
    <div class="modal-content" role="dialog" aria-modal="true" tabindex="-1">
        <h2 data-i18n="welcome_title">Welcome to the French Study App!</h2>
        <p style="margin: 1rem 0;" data-i18n="welcome_instructions">To begin, please load one or more `.txt` files containing your words.</p>
        <div id="welcomeActions" class="welcome-actions">
          <div class="settings-section">
            <div class="settings-section-title">Files</div>
            <div class="settings-card">
              <div class="settings-item" style="justify-content:center;">
                <button id="welcomeAddBtn" class="panel-link">Add Word List‚Ä¶</button>
              </div>
            </div>
            <div class="settings-note">Tip: You can also drag & drop files anywhere on the page.</div>
          </div>
          <div id="iosFilePickerRow" style="display:none; margin-top: 0.75rem;">
            <input type="file" id="iosFileInput" accept=".txt" multiple />
          </div>
        </div>
        <div id="welcomeVersion" class="version-inline"></div>
    </div>
  </div>

  <div id="settingsModal" class="modal">
    <div class="modal-content" role="dialog" aria-modal="true" tabindex="-1">
      <div class="modal-header">
        <h2 data-i18n="settings_title">Settings</h2>
        <button class="icon-btn close-btn" data-i18n-title="label_close" data-i18n-aria-label="label_close" aria-label="Close" title="Close">&times;</button>
      </div>
      <div class="modal-section">
        <p style="margin:0; color:#666;">Controls have moved to the Menu (‚ò∞).</p>
      </div>
      <div class="modal-section">
        <label style="display:block; font-weight:600; margin-bottom:0.5rem;">System</label>
        <button class="btn btn-secondary" id="resetAppBtn" type="button">Reset App (Reload)</button>
      </div>
      <div id="wordListsSection" class="modal-section" style="display: none;">
        <label data-i18n="label_active_word_lists">Active Word Lists</label>
        <div id="wordListsOptions" class="word-lists-options"></div>
      </div>
    </div>
  </div>

  <div id="helpModal" class="modal">
    <div class="modal-content" role="dialog" aria-modal="true" tabindex="-1">
        <div class="modal-header"><h2 data-i18n="help_title">Help</h2><button class="icon-btn close-btn" data-i18n-title="label_close" data-i18n-aria-label="label_close" aria-label="Close" title="Close">&times;</button></div>
        <div class="modal-section">
            <h4 data-i18n="help_getting_started">üöÄ Getting Started</h4>
            <p data-i18n="help_getting_started_body">Load a word list by dragging one or more <code>.txt</code> files onto the page, or by clicking the welcome screen to browse your files.</p>
        </div>
        <div class="modal-section">
            <h4 data-i18n="help_main_controls">üéÆ Main Controls</h4>
            <ul>
                <li data-i18n="help_main_controls_next"><b>Next (Space):</b> Proceeds to the next word.</li>
                <li data-i18n="help_main_controls_repeat"><b>Repeat (R):</b> Repeats the audio for the current word.</li>
                <li data-i18n="help_main_controls_show"><b>Show (S):</b> Instantly reveals the text of the current word.</li>
            </ul>
        </div>
        <div class="modal-section">
            <h4 data-i18n="help_privative_title">üß© Privative Prefix Quiz</h4>
            <p data-i18n="help_privative_body">When your list has words that begin with <b>un</b> or <b>une</b>, enable the Privative Prefix mode in Settings. You will see the base word like ‚Äú<b>‚Ä¶</b> ami‚Äù. Choose the correct prefix with the buttons. If you skip, the answer is recorded as ‚Äú<b>‚Ä¶</b> ami‚Äù in Answers.</p>
        </div>
        <div class="modal-section">
            <h4 data-i18n="help_settings">‚öôÔ∏è Settings</h4>
            <p data-i18n="help_settings_body">Click the gear icon to manage settings. You can choose from different study modes, select voices, and enable/disable your loaded word lists for the current session. Use ‚ÄúTest Voice‚Äù to preview the current voice.</p>
        </div>
        <div class="modal-section">
            <h4 data-i18n="help_panels">‚ÜîÔ∏è Panels</h4>
            <p data-i18n="help_panels_body">On desktop, you can click the <b>‚Äπ</b> icon on the "Answers" panel to collapse and expand it.</p>
        </div>
    </div>
  </div>

  <div id="wordListModal" class="modal">
     <div class="modal-content" role="dialog" aria-modal="true" tabindex="-1">
      <div class="modal-header"><h2 data-i18n="word_list_modal_title">Current Word List</h2><button class="icon-btn close-btn" data-i18n-title="label_close" data-i18n-aria-label="label_close" aria-label="Close" title="Close">&times;</button></div>
      <div class="word-list" id="wordListContent"></div>
    </div>
  </div>
  
  <div id="historyModal" class="modal">
     <div class="modal-content" role="dialog" aria-modal="true" tabindex="-1">
      <div class="modal-header"><h2 data-i18n="history_title">Answers</h2><button class="icon-btn close-btn" data-i18n-title="label_close" data-i18n-aria-label="label_close" aria-label="Close" title="Close">&times;</button></div>
      <div id="historyModalContent" class="word-list"></div>
    </div>
  </div>

  <!-- App Menu: mobile-friendly hamburger contents -->
  <div id="menuModal" class="modal">
    <!-- floating close aligned to hamburger -->
    <button id="menuCloseOverlay" aria-label="Close" title="Close">‚úï</button>
    <div class="modal-content" role="dialog" aria-modal="true" tabindex="-1">
      <div class="menu-shell">
        <section id="menuPanel" class="panel" aria-hidden="true" role="dialog" aria-modal="true" aria-labelledby="menuPanelTitle">
          <div class="panel-header">
            <h2 id="menuPanelTitle" style="margin:0">Settings</h2>
          </div>
          <div class="panel-body">
            <!-- Grouped settings mockup (iOS-style) -->
            <div class="settings-section">
              <div class="settings-section-title">GENERAL</div>
              <div class="settings-card">
                <div class="settings-item" id="rowLanguage" role="button" tabindex="0">
                  <div class="settings-label">Language</div>
                  <div class="settings-value" id="settingsLangValue">English</div>
                  <div class="settings-chevron">‚Ä∫</div>
                  <!-- Keep original language buttons hidden for logic -->
                  <div style="position:absolute; right:10px; top:50%; transform:translateY(-50%); display:none; gap:.5rem;">
                    <button type="button" class="language-flag" id="menuLangEn" aria-label="English" title="English">üá∫üá∏</button>
                    <button type="button" class="language-flag" id="menuLangFr" aria-label="Fran√ßais" title="Fran√ßais">üá´üá∑</button>
                  </div>
                </div>
                <div class="settings-item">
                  <div class="settings-label" data-i18n="label_shuffle">Shuffle Words</div>
                  <input type="checkbox" id="shuffleToggle" class="ios-switch" />
                </div>
                <div class="settings-item" style="position:relative;">
                  <div class="settings-label">Study Mode</div>
                  <div class="settings-value" id="settingsModeValue">Listen then repeat</div>
                  <div class="settings-chevron">‚Ä∫</div>
                  <select id="studyModeSelect" class="overlay-select">
                    <option value="listenRead" data-i18n="mode_listen_read">Listen and read</option>
                    <option value="readThenSay" data-i18n="mode_read_then_say">Read then say</option>
                    <option value="listenThenRepeat" data-i18n="mode_listen_then_repeat" selected>Listen then repeat</option>
                    <option value="articlesDef" data-i18n="mode_articles_def">Articles d√©finis (le/la)</option>
                    <option value="articlesIndef" data-i18n="mode_articles_indef">Articles ind√©finis (un/une)</option>
                  </select>
                </div>
              </div>
            </div>

            <div class="settings-section">
              <div class="settings-section-title">VOICE CONFIGURATION</div>
              <div class="settings-card">
                <div class="settings-item" style="position:relative;">
                  <div class="settings-label">Voice</div>
                  <div class="settings-value" id="settingsVoiceValue">‚Äî</div>
                  <div class="settings-chevron">‚Ä∫</div>
                  <select id="voiceSelect" class="overlay-select"></select>
                  <button class="btn btn-secondary" id="voiceTestBtn" type="button" style="display:none">Test Voice</button>
                  <div id="iosVoiceHint" class="ios-voice-hint" style="display:none;"></div>
                </div>
              </div>
            </div>

            <div class="settings-section">
              <div class="settings-section-title">INTEGRATIONS</div>
              <div class="settings-card">
                <div class="settings-item" id="rowEleven" role="button" tabindex="0">
                  <div class="settings-label">ElevenLabs</div>
                  <div class="settings-value" id="elevenStatus"></div>
                  <div class="settings-chevron">‚Ä∫</div>
                </div>
                <div class="settings-item" id="rowOpenAI" role="button" tabindex="0">
                  <div class="settings-label">OpenAI</div>
                  <div class="settings-value" id="openaiStatus"></div>
                  <div class="settings-chevron">‚Ä∫</div>
                </div>
              </div>
            </div>

            <div class="settings-section">
              <div class="settings-section-title">DATA & SYSTEM</div>
              <div class="settings-card">
                <div class="settings-item" id="rowFiles" role="button" tabindex="0">
                  <div class="settings-label">Active Word Lists</div>
                  <div class="settings-value" id="settingsActiveListsCount">0</div>
                  <div class="settings-chevron">‚Ä∫</div>
                </div>
                <div class="settings-item">
                  <button id="menuResetAppBtn" class="settings-danger" style="background:none;border:0;font:inherit;padding:0;margin:0;">Reset App (Reload)</button>
                </div>
              </div>
            </div>

            <div class="settings-footer">
              <div id="menuVersion" class="version-inline" style="display:inline-block; padding:0; margin:0;"></div>
            </div>

          </div>
        </section>

        <!-- Subpanel: Language (sibling of #menuPanel) -->
        <!-- Note: subpanels are outside #menuPanel so its header hiding rule doesn't affect them -->
        <!-- Subpanel: Language -->
        <section id="langPanel" class="panel subpanel" aria-hidden="true" aria-labelledby="langPanelTitle">
              <div class="panel-header">
                <button class="panel-back" data-back="langPanel">‚Äπ Back</button>
                <h2 id="langPanelTitle" style="margin:0">Language</h2>
                <div style="width:44px"></div>
              </div>
              <div class="panel-body">
                <div class="settings-section-title">General ‚Üí Language</div>
                <div class="settings-card">
                  <div class="settings-item" id="langOptionEn" role="button" tabindex="0">
                    <div class="settings-label">English</div>
                    <div class="settings-check" id="langCheckEn" style="display:none;">‚úì</div>
                  </div>
                  <div class="settings-item" id="langOptionFr" role="button" tabindex="0">
                    <div class="settings-label">Fran√ßais</div>
                    <div class="settings-check" id="langCheckFr" style="display:none;">‚úì</div>
                  </div>
                </div>
              </div>
            </section>

            <!-- Subpanel: ElevenLabs -->
            <section id="elevenPanel" class="panel subpanel" aria-hidden="true" aria-labelledby="elevenPanelTitle">
              <div class="panel-header">
                <button class="panel-back" data-back="elevenPanel">‚Äπ Back</button>
                <h2 id="elevenPanelTitle" style="margin:0">ElevenLabs</h2>
                <div style="width:44px"></div>
              </div>
              <div class="panel-body">
                <div class="settings-section-title">Integrations ‚Üí ElevenLabs</div>
                <div class="settings-card">
                  <div class="settings-item" style="flex-direction:column; align-items:stretch; gap:8px;">
                    <div class="settings-label" style="font-weight:700;">API Key</div>
                    <input id="elevenKeyInput" type="password" placeholder="elevenlabs_api_key" style="flex:1; min-width:220px; padding:.5rem;"/>
                    <div id="elevenKeyMasked" class="settings-note">No key set</div>
                  </div>
                </div>
                <div class="settings-card" style="margin-top:12px;">
                  <div class="settings-item" style="justify-content:center; gap: 12px;">
                    <button class="panel-link" id="elevenLoadFileBtn" type="button">Choose Key File‚Ä¶</button>
                    <input type="file" id="elevenKeyFile" accept=".key,.txt" style="display:none;"/>
                  </div>
                </div>
                <div class="settings-card" style="margin-top:12px;">
                  <div class="settings-item" style="justify-content:center;">
                    <button class="btn-destructive" id="elevenClearBtn" type="button" style="font-size: 3em; line-height: 1;">Delete Key</button>
                  </div>
                </div>
                <div class="settings-note">Adds ElevenLabs voices ‚ÄúJosh‚Äù (male) and ‚ÄúBella‚Äù (female) to the selector using non‚Äëstreaming playback (fr‚ÄëFR).</div>
              </div>
            </section>

            <!-- Subpanel: OpenAI -->
            <section id="openaiPanel" class="panel subpanel" aria-hidden="true" aria-labelledby="openaiPanelTitle">
              <div class="panel-header">
                <button class="panel-back" data-back="openaiPanel">‚Äπ Back</button>
                <h2 id="openaiPanelTitle" style="margin:0">OpenAI</h2>
                <div style="width:44px"></div>
              </div>
              <div class="panel-body">
                <div class="settings-section-title">Integrations ‚Üí OpenAI</div>
                <div class="settings-card">
                  <div class="settings-item" style="flex-direction:column; align-items:stretch; gap:8px;">
                    <div class="settings-label" style="font-weight:700;">API Key</div>
                    <input id="openaiKeyInput" type="password" placeholder="sk-..." style="flex:1; min-width:220px; padding:.5rem;"/>
                    <div id="openaiKeyMasked" class="settings-note">No key set</div>
                  </div>
                </div>
                <div class="settings-card" style="margin-top:12px;">
                  <div class="settings-item" style="justify-content:center; gap: 12px;">
                    <button class="panel-link" id="openaiLoadFileBtn" type="button">Choose Key File‚Ä¶</button>
                    <input type="file" id="openaiKeyFile" accept=".key,.txt" style="display:none;"/>
                  </div>
                </div>
                <div class="settings-card" style="margin-top:12px;">
                  <div class="settings-item" style="justify-content:center;">
                    <button class="btn-destructive" id="openaiClearBtn" type="button" style="font-size: 3em; line-height: 1;">Delete Key</button>
                  </div>
                </div>
                <div class="settings-note">Adds OpenAI voices ‚ÄúEcho‚Äù and ‚ÄúNova‚Äù to the selector using a low‚Äëlatency model.</div>
              </div>
            </section>

            <!-- Subpanel: Files -->
            <section id="filesPanel" class="panel subpanel" aria-hidden="true" aria-labelledby="filesPanelTitle">
              <div class="panel-header">
                <button class="panel-back" data-back="filesPanel">‚Äπ Back</button>
                <h2 id="filesPanelTitle" style="margin:0">Files</h2>
                <div style="width:44px"></div>
              </div>
              <div class="panel-body">
                <div class="settings-section-title">Data & System ‚Üí Files</div>
                <div class="settings-section">
                  <div class="settings-card" id="filesListCard">
                    <div id="menuWordListsSection" class="menu-field" style="margin:0; padding:0; width:100%;">
                      <div id="menuWordListsOptions" class="word-lists-options" style="padding: 0;"></div>
                    </div>
                  </div>
                </div>
                <div class="settings-card" style="margin-top:12px;">
                  <div class="settings-item" style="justify-content:center;">
                    <button id="btnAddWordList" class="panel-link" type="button">Add Word List‚Ä¶</button>
                    <input type="file" id="menuFileInput" accept=".txt" multiple style="display:none;" />
                  </div>
                </div>
                <div class="settings-note">Tip: You can also drag & drop files anywhere on the page.</div>
              </div>
            </section>
          </div>
  </div>

  <div id="confirmationDialog" class="modal">
    <div class="modal-content" style="text-align: center;" role="dialog" aria-modal="true" tabindex="-1">
      <h3 data-i18n="confirm_title">Reset Study Progress</h3>
      <p id="confirmationDialogText"></p>
      <div style="display: flex; justify-content: center; gap: 1rem; margin-top: 1rem;">
        <button class="btn btn-primary" id="confirmReset" data-i18n="confirm_yes_continue">Yes, Continue</button>
        <button class="btn btn-secondary" id="cancelReset" data-i18n="confirm_cancel">Cancel</button>
      </div>
    </div>
  </div>

  <div id="toastNotification" class="toast"></div>
  <div id="appVersionCorner" class="app-version-corner"></div>

<script>
    'use strict';
    const i18n = {
      en: {
        page_title: "üá´üá∑ French Listening Study",
        header_title: "üá´üá∑ French Study",
        title_help: "Help",
        title_settings: "Settings",
        title_toggle_history: "Toggle History Panel",
        welcome_message: "Welcome!",
        btn_view_list: "View List",
        btn_history: "History",
        status_load_prompt: "Load a word list to start.",
        file_info_none: "No file loaded.",
        welcome_title: "Welcome to the French Study App!",
        welcome_instructions: "To begin, please load one or more `.txt` files containing your words.",
        welcome_drag_drop: "Drag & Drop File(s) Here",
        welcome_or: "or",
        welcome_browse: "Browse Files",
        settings_title: "Settings",
        label_active_word_lists: "Active Word Lists",
        btn_next: "Next (Space)", btn_repeat: "Repeat (R)", btn_show: "Show (S)", btn_toggleVoice: "Voice (V)",
        status_ready: "Ready to start a new session", history_title: "Answers",
        label_voice: "Voice:", label_studyMode: "Study Mode",
        label_shuffle: "Shuffle words", label_seconds: "seconds",
        mode_simultaneous: "Listen and Read simultaneously",
        mode_listen_read: "Listen and read",
        mode_read_then_say: "Read then say",
        mode_listen_then_repeat: "Listen then repeat",
        mode_articles_def: "Definite articles (le/la)",
        mode_articles_indef: "Indefinite articles (un/une)",
        btn_prefix_un: "Prefix: un",
        btn_prefix_une: "Prefix: une",
        btn_prefix_le: "Prefix: le",
        btn_prefix_la: "Prefix: la",
        prefix_prompt: "Choose the correct prefix (un/une)",
        toast_correct_prefix: "‚úÖ Correct! {prefix} + {base}",
        toast_wrong_prefix: "‚ùå Not quite. It was {prefix} + {base}",
        help_title: "Help",
        word_list_modal_title: "Current Word List",
        help_getting_started: "üöÄ Getting Started",
        help_getting_started_body: "Load a word list by dragging one or more <code>.txt</code> files onto the page, or by clicking the welcome screen to browse your files.",
        help_main_controls: "üéÆ Main Controls",
        help_main_controls_next: "<b>Next (Space):</b> Proceeds to the next word.",
        help_main_controls_repeat: "<b>Repeat (R):</b> Repeats the audio for the current word.",
        help_main_controls_show: "<b>Show (S):</b> Instantly reveals the text of the current word.",
        help_privative_title: "üß© Privative Prefix Quiz",
        help_privative_body: "When your list has words that begin with <b>un</b> or <b>une</b>, enable the Privative Prefix mode in Settings. You will see the base word like ‚Äú<b>‚Ä¶</b> ami‚Äù. Choose the correct prefix with the buttons. If you skip, the answer is recorded as ‚Äú<b>‚Ä¶</b> ami‚Äù in Answers.",
        help_settings: "‚öôÔ∏è Settings",
        help_settings_body: "Click the gear icon to manage settings. You can choose from different study modes, select voices, and enable/disable your loaded word lists for the current session.",
        help_panels: "‚ÜîÔ∏è Panels",
        help_panels_body: "On desktop, you can click the <b>‚Äπ</b> icon on the \"Answers\" panel to collapse and expand it.",
        btn_test_voice: "Test Voice",
        label_close: "Close",
        test_phrase: "Bonjour !",
        voice_hint_ios: "Tip (iOS): After first playback, reopen Settings to refresh French voices.",
        confirm_title: "Reset Study Progress",
        confirm_yes_continue: "Yes, Continue",
        confirm_cancel: "Cancel",
        no_voices: "üó£Ô∏è No Voices Available",
        indicator_mode_prefix: "üìñ Mode:",
        indicator_shuffle_on: "üîÄ Shuffle: On",
        indicator_shuffle_off: "‚û°Ô∏è Shuffle: Off",
        status_word_progress: "Word {current}/{total}",
        opt_system_french_voice: "System Default French Voice",
        words_lower: "words",
        file_info: "{wordCount} words from {fileCount} file(s)",
        history_empty: "No words have been revealed yet in this session.",
        restart_message: "üéâ Starting over from the beginning.", listening: "Listening...", reveal_prompt: "???", ready_to_start: "Ready to start!",
        instr_listen: "Listen please.",
        instr_repeat: "Repeat what you did hear.",
        instr_read_say: "Say what you read.",
        instr_skip_next: "You may skip to the next word.",
        session_complete: "üéâ Session Complete!", start_next_session: "Start Next (Space)",
        toast_single_file: "‚úÖ {count} words loaded ‚Äì ready to study!",
        toast_multi_file: "‚úÖ {wordCount} words from {fileCount} files loaded ‚Äì ready to study!",
        confirm_shuffle: "Changing shuffle mode will reset your progress. Are you sure?",
        confirm_word_list: "Changing active word lists will reset your progress. Are you sure?",
        confirm_reset: "This will clear local & session storage, API keys, cached files, and reload the app. Continue?"
      },
      fr: {
        page_title: "üá´üá∑ √âtude d'√©coute en fran√ßais",
        header_title: "üá´üá∑ √âtude de fran√ßais",
        title_help: "Aide",
        title_settings: "Param√®tres",
        title_toggle_history: "Basculer le panneau d'historique",
        welcome_message: "Bienvenue !",
        btn_view_list: "Voir la liste",
        btn_history: "Historique",
        status_load_prompt: "Chargez une liste de mots pour commencer.",
        file_info_none: "Aucun fichier charg√©.",
        welcome_title: "Bienvenue dans l'application d'√©tude de fran√ßais !",
        welcome_instructions: "Pour commencer, chargez un ou plusieurs fichiers `.txt` contenant vos mots.",
        welcome_drag_drop: "Glissez-d√©posez les fichiers ici",
        welcome_or: "ou",
        welcome_browse: "Parcourir les fichiers",
        settings_title: "Param√®tres",
        label_active_word_lists: "Listes de mots actives",
        btn_next: "Suivant (Espace)", btn_repeat: "R√©p√©ter (R)", btn_show: "Afficher (S)", btn_toggleVoice: "Voix (V)",
        status_ready: "Pr√™t √† commencer une nouvelle session", history_title: "R√©ponses",
        label_voice: "Voix :", label_studyMode: "Mode d'√©tude",
        label_shuffle: "M√©langer les mots", label_seconds: "secondes",
        mode_simultaneous: "√âcouter et lire simultan√©ment",
        mode_listen_read: "√âcouter et lire",
        mode_read_then_say: "Lire puis dire",
        mode_listen_then_repeat: "√âcouter puis r√©p√©ter",
        mode_articles_def: "Articles d√©finis (le/la)",
        mode_articles_indef: "Articles ind√©finis (un/une)",
        btn_prefix_un: "Pr√©fixe : un",
        btn_prefix_une: "Pr√©fixe : une",
        btn_prefix_le: "Pr√©fixe : le",
        btn_prefix_la: "Pr√©fixe : la",
        prefix_prompt: "Choisissez le bon pr√©fixe (un/une)",
        toast_correct_prefix: "‚úÖ Correct ! {prefix} + {base}",
        toast_wrong_prefix: "‚ùå Pas tout √† fait. C'√©tait {prefix} + {base}",
        help_title: "Aide",
        word_list_modal_title: "Liste de mots actuelle",
        help_getting_started: "üöÄ Pour commencer",
        help_getting_started_body: "Chargez une liste de mots en faisant glisser un ou plusieurs fichiers <code>.txt</code> sur la page, ou cliquez sur l'√©cran d'accueil pour parcourir vos fichiers.",
        help_main_controls: "üéÆ Contr√¥les principaux",
        help_main_controls_next: "<b>Suivant (Espace):</b> Passe au mot suivant.",
        help_main_controls_repeat: "<b>R√©p√©ter (R):</b> R√©p√®te l'audio du mot actuel.",
        help_main_controls_show: "<b>Afficher (S):</b> R√©v√®le instantan√©ment le texte du mot actuel.",
        help_privative_title: "üß© Pr√©fixe privatif",
        help_privative_body: "Lorsque votre liste contient des mots commen√ßant par <b>un</b> ou <b>une</b>, activez le mode Pr√©fixe privatif dans les Param√®tres. Vous verrez le mot de base comme ¬´ <b>‚Ä¶</b> ami ¬ª. Choisissez le bon pr√©fixe avec les boutons. Si vous passez, la r√©ponse est enregistr√©e comme ¬´ <b>‚Ä¶</b> ami ¬ª dans R√©ponses.",
        help_settings: "‚öôÔ∏è Param√®tres",
        help_settings_body: "Cliquez sur l'ic√¥ne d'engrenage pour g√©rer les param√®tres. Vous pouvez choisir diff√©rents modes d'√©tude, s√©lectionner des voix et activer/d√©sactiver vos listes de mots charg√©es pour la session en cours.",
        help_panels: "‚ÜîÔ∏è Panneaux",
        help_panels_body: "Sur ordinateur, vous pouvez cliquer sur l'ic√¥ne <b>‚Äπ</b> du panneau \"R√©ponses\" pour le r√©duire ou l'agrandir.",
        btn_test_voice: "Tester la voix",
        label_close: "Fermer",
        test_phrase: "Bonjour !",
        voice_hint_ios: "Astuce (iOS) : Apr√®s la premi√®re lecture, rouvrez Param√®tres pour actualiser les voix fran√ßaises.",
        confirm_title: "R√©initialiser la progression d'√©tude",
        confirm_yes_continue: "Oui, continuer",
        confirm_cancel: "Annuler",
        no_voices: "üó£Ô∏è Aucune voix disponible",
        indicator_mode_prefix: "üìñ Mode :",
        indicator_shuffle_on: "üîÄ M√©lange : Activ√©",
        indicator_shuffle_off: "‚û°Ô∏è M√©lange : D√©sactiv√©",
        status_word_progress: "Mot {current}/{total}",
        opt_system_french_voice: "Voix fran√ßaise par d√©faut du syst√®me",
        words_lower: "mots",
        file_info: "{wordCount} mots de {fileCount} fichier(s)",
        history_empty: "Aucun mot n'a encore √©t√© r√©v√©l√© dans cette session.",
        restart_message: "üéâ Reprise depuis le d√©but.", listening: "√âcoute...", reveal_prompt: "???", ready_to_start: "Pr√™t √† commencer !",
        instr_listen: "Veuillez √©couter.",
        instr_repeat: "R√©p√©tez ce que vous avez entendu.",
        instr_read_say: "Dites ce que vous lisez.",
        instr_skip_next: "Vous pouvez passer au mot suivant.",
        session_complete: "üéâ Session termin√©e !", start_next_session: "Commencer (Espace)",
        toast_single_file: "‚úÖ {count} mots charg√©s ‚Äì pr√™t √† √©tudier !",
        toast_multi_file: "‚úÖ {wordCount} mots de {fileCount} fichiers charg√©s ‚Äì pr√™t √† √©tudier !",
        confirm_shuffle: "Changer le mode de m√©lange r√©initialisera votre progression. C'est certain ?",
        confirm_word_list: "Changer les listes de mots actives r√©initialisera votre progression. C'est certain ?",
        confirm_reset: "Ceci va effacer le stockage local et de session, les cl√©s API, les fichiers en cache et recharger l'application. Continuer ?"
      }
    };

    // --- GLOBAL VARIABLES ---
    let wordLists = {}; // { filename: { words: [], enabled: true } }
    let words = [], currentIndex = 0, currentWord = "";
    let availableVoices = [], currentVoice = "system", displayHistory = [];
    let studyMode = "listenThenRepeat"; // default
    // Deprecated timer settings removed
    let countdownInterval = null;
    let isInSpeakFirstMode = false; // legacy; no longer used for timers
    let readSayStage = 0; // 0=new word, 1=shown, 2=spoken (advance next)
    let listenRepeatStage = 0; // 0=new word, 1=awaiting user after speak, 2=word shown awaiting next
    let shuffleEnabled = false;
    let originalWordOrder = [];
    let isSessionComplete = false;
    const APP_VERSION = 'v1.6.3-beta';
    // Articles quiz state
    let prefixWords = [];
    let prefixWordsIndef = [];
    let prefixWordsDef = [];
    let prefixIndex = 0;
    let currentBaseWord = "";
    let currentExpectedPrefix = ""; // 'un' or 'une'
    let privativeAnswered = true;
    const synth = window.speechSynthesis;
    let curLang = "en";
    let confirmationCallback = null;
    // OpenAI TTS integration
    let openaiKey = null; // stored locally
    const OPENAI_TTS_MODEL = 'gpt-4o-mini-tts';
    let openaiAudio = null;
    let elevenKey = null; // ElevenLabs API key (local)

    // --- ENV / BROWSER DETECTION ---
    const UA = navigator.userAgent || '';
    const isIOS = /iPad|iPhone|iPod/.test(UA) || (/Macintosh/.test(UA) && 'ontouchend' in document);
    const isFirefox = /Firefox\/\d+/.test(UA);
    const isChromium = !isIOS && /(Chrome|Chromium|Edg|Brave)\//.test(UA) && !/OPR\//.test(UA);
    const isSafari = !isChromium && (/Safari\//.test(UA) || isIOS);

    // --- DOM ELEMENTS ---
    const progressCircle = document.querySelector('.progress-ring__circle');
    const radius = progressCircle.r.baseVal.value;
    const circumference = radius * 2 * Math.PI;
    progressCircle.style.strokeDasharray = `${circumference} ${circumference}`;
    progressCircle.style.strokeDashoffset = circumference;
    const allModals = document.querySelectorAll('.modal');
    const progressBarFill = document.getElementById('progressBarFill');
    const countdownTopbarFill = document.getElementById('countdownTopbarFill');
    const nextBtn = document.getElementById('nextBtn');
    const repeatBtn = document.getElementById('repeatBtn');
    const showBtn = document.getElementById('showBtn');
    const voiceBtn = document.getElementById('voiceBtn');
    const welcomeModal = document.getElementById('welcomeModal');
    const settingsModal = document.getElementById('settingsModal');
    const helpModal = document.getElementById('helpModal');
    const wordListModal = document.getElementById('wordListModal');
    const confirmationDialog = document.getElementById('confirmationDialog');
    const toastNotification = document.getElementById('toastNotification');
    const historyModal = document.getElementById('historyModal');
    const historyModalContent = document.getElementById('historyModalContent');
    const historyBtn = document.getElementById('historyBtn');


    // --- CORE FUNCTIONS ---
    function setLanguage(lang) {
      curLang = lang;
      document.getElementById('langEn').classList.toggle('active', lang === 'en');
      document.getElementById('langFr').classList.toggle('active', lang === 'fr');
      // mirror selection in menu flags if present
      const mEn = document.getElementById('menuLangEn');
      const mFr = document.getElementById('menuLangFr');
      if (mEn && mFr) { mEn.classList.toggle('active', lang === 'en'); mFr.classList.toggle('active', lang === 'fr'); }
      // update grouped settings value label
      const settingsLangValue = document.getElementById('settingsLangValue');
      if (settingsLangValue) settingsLangValue.textContent = (lang === 'en') ? 'English' : 'Fran√ßais';
      document.querySelectorAll("[data-i18n]").forEach(el => {
        const key = el.getAttribute("data-i18n");
        if (i18n[lang] && i18n[lang][key]) {
          const val = i18n[lang][key];
          if (/[<>&]/.test(val)) {
            el.innerHTML = val;
          } else {
            el.textContent = val;
          }
        }
      });
      document.querySelectorAll('[data-i18n-title]').forEach(el => {
        const key = el.getAttribute('data-i18n-title');
        if (i18n[lang] && i18n[lang][key]) {
          el.setAttribute('title', i18n[lang][key]);
        }
      });
      document.querySelectorAll('[data-i18n-aria-label]').forEach(el => {
        const key = el.getAttribute('data-i18n-aria-label');
        if (i18n[lang] && i18n[lang][key]) {
          el.setAttribute('aria-label', i18n[lang][key]);
        }
      });
      if (words.length > 0) {
        const msg = i18n[lang].status_word_progress.replace('{current}', currentIndex).replace('{total}', words.length);
        updateStatusInfo(msg);
      } else {
        updateStatusInfo(i18n[lang].status_load_prompt);
      }
      updateAllIndicators();
    }
    
    function populateVoiceList() {
        const voices = synth.getVoices();
        if (voices.length > 0) {
            loadVoices(voices);
        } else {
            synth.onvoiceschanged = () => {
                const updatedVoices = synth.getVoices();
                loadVoices(updatedVoices);
            };
        }
    }

    function scoreFrenchVoice(voice) {
      const name = (voice.name || '').toLowerCase();
      const lang = (voice.lang || '').toLowerCase();
      const uri = (voice.voiceURI || '').toLowerCase();
      let score = 0;
      // Language match priority
      if (lang.startsWith('fr-fr')) score += 40;
      else if (lang.startsWith('fr-ca')) score += 30;
      else if (lang.startsWith('fr')) score += 20; // fr-be, fr-ch, etc.
      // Prefer local installed voices
      if (voice.localService) score += 10;
      // Prefer high quality indicators in name/URI (Safari often encodes in URI)
      if (name.includes('siri') || uri.includes('siri')) score += 60;
      if (name.includes('premium') || uri.includes('premium')) score += 50;
      if (name.includes('enhanced') || uri.includes('enhanced')) score += 40;
      if (name.includes('neural') || uri.includes('neural') || name.includes('hq') || uri.includes('hq')) score += 30;
      if (uri.includes('compact')) score -= 20; // penalize compact quality
      if (voice.default) score += 10;
      return score;
    }

    function bestFrenchVoice() {
      if (!availableVoices || availableVoices.length === 0) return null;
      const fr = availableVoices.filter(v => (v.lang || '').toLowerCase().startsWith('fr'));
      if (fr.length === 0) return null;
      // Safari preference: Thomas if available
      if (isSafari) {
        // On Apple, prefer Thomas, then Audrey, then Am√©lie
        const pickBy = (name) => fr.filter(v => (v.name || '').toLowerCase().includes(name)).sort((a,b)=>scoreFrenchVoice(b)-scoreFrenchVoice(a));
        const seq = ['thomas','audrey','amelie','am√©lie'];
        for (const key of seq) { const hits = pickBy(key); if (hits.length) return hits[0]; }
      }
      return fr.sort((a, b) => scoreFrenchVoice(b) - scoreFrenchVoice(a))[0] || null;
    }

    function loadVoices(voices) {
      availableVoices = voices;
      const vs = document.getElementById("voiceSelect");
      
      vs.innerHTML = ''; 

      const defaultOption = document.createElement("option");
      defaultOption.value = "system";
      defaultOption.textContent = i18n[curLang].opt_system_french_voice;
      vs.appendChild(defaultOption);
      const allFrench = availableVoices.filter(v => (v.lang || '').toLowerCase().startsWith('fr'));
      const qualityKeywords = ['siri', 'enhanced', 'premium', 'neural', 'hq', 'audrey', 'amelie', 'am√©lie', 'thomas'];

      let toShow = [];
      if (isSafari) {
        // Apple platforms: show only specific system voices (Audrey, Am√©lie, Thomas)
        const isAllowedApple = (v) => {
          const n = (v.name || '').toLowerCase();
          return n.includes('thomas') || n.includes('audrey') || n.includes('amelie') || n.includes('am√©lie');
        };
        toShow = allFrench.filter(isAllowedApple).sort((a, b) => scoreFrenchVoice(b) - scoreFrenchVoice(a));
      } else if (isFirefox) {
        // Firefox: prefer high-quality filtered list; fallback to all FR
        const high = allFrench.filter(v => qualityKeywords.some(k => (v.name || '').toLowerCase().includes(k)));
        toShow = (high.length ? high : allFrench).sort((a, b) => scoreFrenchVoice(b) - scoreFrenchVoice(a));
      } else if (isChromium) {
        // Chromium: only show clearly high-quality voices to avoid poor defaults
        const high = allFrench.filter(v => qualityKeywords.some(k => (v.name || '').toLowerCase().includes(k)));
        toShow = high.sort((a, b) => scoreFrenchVoice(b) - scoreFrenchVoice(a));
        if (toShow.length === 0 && currentVoice && currentVoice !== 'system') {
          const saved = allFrench.find(v => v.name === currentVoice);
          if (saved) toShow = [saved];
        }
      } else {
        toShow = allFrench.sort((a, b) => scoreFrenchVoice(b) - scoreFrenchVoice(a));
      }

      toShow.forEach(voice => {
        const opt = document.createElement("option");
        opt.value = voice.name;
        opt.textContent = `${voice.name} (${voice.lang})`;
        vs.appendChild(opt);
      });

      // Append OpenAI voices when API key is set
      if (openaiKey) {
        const group = document.createElement('optgroup');
        group.label = 'OpenAI TTS';
        const echo = document.createElement('option'); echo.value = 'openai:echo'; echo.textContent = 'Echo (OpenAI)';
        const nova = document.createElement('option'); nova.value = 'openai:nova'; nova.textContent = 'Nova (OpenAI)';
        group.appendChild(echo); group.appendChild(nova);
        vs.appendChild(group);
      }

      // Add ElevenLabs voices (fr-FR, non-streaming) when key is present
      try {
        if (window._ELEVEN && window._ELEVEN.key) {
          const group2 = document.createElement('optgroup');
          group2.label = 'ElevenLabs (fr-FR)';
          // One male and one female public sample voices
          const male = document.createElement('option'); male.value = 'eleven:TxGEqnHWrfWFTfGW9XjX'; male.textContent = 'Josh ‚Äî male (ElevenLabs)';
          const female = document.createElement('option'); female.value = 'eleven:EXAVITQu4vr4xnSDxMaL'; female.textContent = 'Bella ‚Äî female (ElevenLabs)';
          group2.appendChild(male); group2.appendChild(female);
          vs.appendChild(group2);
        }
      } catch (_) {}

      // Preserve current selection if possible
      let existingIndex = Array.from(vs.options).findIndex(o => o.value === currentVoice);
      if (existingIndex >= 0) {
        vs.selectedIndex = existingIndex;
      } else if (isSafari) {
        // Prefer Thomas on Apple if present, else Audrey, else Am√©lie
        const findPref = (name) => Array.from(vs.options).findIndex(o => (o.value || '').toLowerCase().includes(name));
        const thomasIndex = findPref('thomas');
        const audreyIndex = findPref('audrey');
        const amelieIndex = findPref('amelie');
        const prefIndex = [thomasIndex, audreyIndex, amelieIndex].find(i => i > 0);
        if (typeof prefIndex === 'number') {
          vs.selectedIndex = prefIndex;
          currentVoice = vs.options[prefIndex].value;
        } else {
          vs.selectedIndex = 0;
          currentVoice = 'system';
        }
      } else {
        vs.selectedIndex = 0;
        currentVoice = 'system';
      }

      updateVoiceIndicator();
      renderVoiceDebug();
    }

    async function handleFileLoad(files) {
        let totalWords = 0;

        const readFile = (file) => new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (event) => resolve(event.target.result);
            reader.onerror = (error) => reject(error);
            reader.readAsText(file);
        });

        for (const file of files) {
            try {
                const content = await readFile(file);
                const fileWords = content.split("\n").filter(w => w.trim());
                if (fileWords.length > 0) {
                  wordLists[file.name] = { words: fileWords, enabled: true };
                  totalWords += fileWords.length;
                }
            } catch (err) {
                showToast(`Error: Could not load ${file.name}.`);
            }
        }

        if (totalWords > 0) {
            generateWordListsUI();
            rebuildActiveWordsList();
            welcomeModal.classList.remove('visible');

            let toastMessage;
            const fileCount = Object.keys(wordLists).length;

            if (fileCount === 1) {
                toastMessage = i18n[curLang].toast_single_file.replace('{count}', totalWords);
            } else {
                toastMessage = i18n[curLang].toast_multi_file.replace('{wordCount}', totalWords).replace('{fileCount}', fileCount);
            }
            showToast(toastMessage);
        }
    }
    
    function shuffleArray(a) { for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[a[i], a[j]] = [a[j], a[i]]; } }

    function initializeStudy() {
      isSessionComplete = false;
      currentIndex = 0;
      currentWord = "";
      readSayStage = 0;
      listenRepeatStage = 0;
      prefixIndex = 0;
      currentBaseWord = "";
      currentExpectedPrefix = "";
      privativeAnswered = true;
      displayHistory = [];
      ['nextBtn', 'repeatBtn', 'showBtn', 'voiceBtn', 'historyBtn'].forEach(id => document.getElementById(id).disabled = words.length === 0);
      document.getElementById('viewListBtn').disabled = words.length === 0;
      nextBtn.textContent = i18n[curLang].btn_next;
      updateStatusInfo('');
      updateDisplayUpper(i18n[curLang].ready_to_start);
      updateInstruction('');
      updateHistoryList();
      updateProgressBar();
      document.getElementById('countdownText').textContent = '--';
      if (countdownTopbarFill) countdownTopbarFill.style.width = '0%';
      // Toggle privative controls visibility
      document.getElementById('privativeControls').style.display = (getSelectedStudyMode() === 'articlesIndef' || getSelectedStudyMode() === 'articlesDef') ? 'flex' : 'none';
      // Set initial labels for prefix buttons according to mode
      (function(){
        const unBtnLbl = document.getElementById('prefixUnBtn');
        const uneBtnLbl = document.getElementById('prefixUneBtn');
        if (unBtnLbl && uneBtnLbl) {
          if (getSelectedStudyMode() === 'articlesDef') { unBtnLbl.textContent = i18n[curLang].btn_prefix_le || 'Prefix: le'; uneBtnLbl.textContent = i18n[curLang].btn_prefix_la || 'Prefix: la'; }
          else { unBtnLbl.textContent = i18n[curLang].btn_prefix_un; uneBtnLbl.textContent = i18n[curLang].btn_prefix_une; }
        }
      })();
      // Shuffle questions for articles mode according to shuffleEnabled
      if ((getSelectedStudyMode() === 'articlesIndef' || getSelectedStudyMode() === 'articlesDef') && prefixWords.length > 0) {
        if (shuffleEnabled) shuffleArray(prefixWords);
        else if (window.prefixOriginalOrder) prefixWords = [...window.prefixOriginalOrder];
      }
    }

    function speakWord(w) {
      if (synth.speaking) synth.cancel();
      // ElevenLabs (non-streaming) selection
      if (typeof currentVoice === 'string' && currentVoice.startsWith('eleven:')) {
        const voiceId = currentVoice.split(':')[1] || '';
        if (voiceId) return speakWithElevenLabs(w, voiceId);
      }
      if (openaiKey && typeof currentVoice === 'string' && currentVoice.startsWith('openai:')) {
        const voice = (currentVoice.split(':')[1] || 'echo');
        return speakWithOpenAITTS(w, voice);
      }
      const u = new SpeechSynthesisUtterance(w);
      let selectedVoice = null;
      if (currentVoice && currentVoice !== 'system') {
        selectedVoice = availableVoices.find(v => v.name === currentVoice) || null;
      }
      if (!selectedVoice) {
        if (isChromium) {
          // On Chromium, letting the platform pick often yields a high‚Äëquality FR voice; avoid overriding.
          u.lang = 'fr-FR';
        } else {
          // On Safari/Firefox, resolve best French voice explicitly to ensure quality.
          const best = bestFrenchVoice();
          if (best) {
            selectedVoice = best;
            u.voice = best;
            u.lang = best.lang || 'fr-FR';
          } else {
            u.lang = 'fr-FR';
          }
        }
      } else {
        u.voice = selectedVoice;
        u.lang = selectedVoice.lang || 'fr-FR';
      }
      u.rate = 0.9;
      return new Promise(resolve => { 
        u.onend = resolve; 
        synth.speak(u); 
        // After first synthesis, some browsers populate voices; try to refresh list lazily
        if (!availableVoices || availableVoices.length === 0 || document.getElementById('voiceSelect').options.length <= 1) {
          setTimeout(populateVoiceList, 0);
        }
      });
    }

    async function speakWithOpenAITTS(text, voice) {
      try {
        if (openaiAudio) { try { openaiAudio.pause(); } catch(_){} }
        const resp = await fetch('https://api.openai.com/v1/audio/speech', {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${openaiKey}`, 'Content-Type': 'application/json' },
          body: JSON.stringify({ model: OPENAI_TTS_MODEL, voice, input: text, format: 'mp3' })
        });
        if (!resp.ok) throw new Error('TTS request failed');
        const buf = await resp.arrayBuffer();
        const blob = new Blob([buf], { type: 'audio/mpeg' });
        const url = URL.createObjectURL(blob);
        openaiAudio = new Audio(url);
        await openaiAudio.play();
        return new Promise(resolve => { openaiAudio.onended = resolve; });
      } catch (e) {
        showToast('OpenAI TTS error (possibly CORS). Falling back.');
        const u = new SpeechSynthesisUtterance(text); synth.speak(u); return new Promise(r=>u.onend=r);
      }
    }

    // ElevenLabs TTS (non-streaming: Create Speech)
    async function speakWithElevenLabs(text, voiceId) {
      try {
        const url = `https://api.elevenlabs.io/v1/text-to-speech/${voiceId}`;
        const resp = await fetch(url, {
          method: 'POST',
          headers: {
            'xi-api-key': (window._ELEVEN && window._ELEVEN.key) || elevenKey || '',
            'Accept': 'audio/mpeg',
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            text,
            model_id: 'eleven_multilingual_v2',
            language: 'fr-FR',
            voice_settings: { stability: 0.5, similarity_boost: 0.7, style: 0.0, use_speaker_boost: true }
          })
        });
        if (!resp.ok) throw new Error('ElevenLabs TTS failed');
        const buf = await resp.arrayBuffer();
        const blob = new Blob([buf], { type: 'audio/mpeg' });
        const urlObj = URL.createObjectURL(blob);
        const audio = new Audio(urlObj);
        await audio.play();
        return new Promise(resolve => { audio.onended = resolve; });
      } catch (e) {
        showToast('ElevenLabs TTS error (maybe CORS). Falling back.');
        const u = new SpeechSynthesisUtterance(text); synth.speak(u); return new Promise(r=>u.onend=r);
      }
    }

    function startCountdown(seconds) {
      if (countdownInterval) clearInterval(countdownInterval);
      progressCircle.style.transition = 'stroke-dashoffset 0.1s linear';
      
      const countdownTextEl = document.getElementById('countdownText');
      const totalDuration = seconds * 1000;
      let startTime = Date.now();
      if (countdownTopbarFill) countdownTopbarFill.style.width = '100%';

      countdownInterval = setInterval(() => {
        const elapsedTime = Date.now() - startTime;
        if (elapsedTime >= totalDuration) {
          clearInterval(countdownInterval);
          progressCircle.style.strokeDashoffset = circumference;
          countdownTextEl.textContent = '--';
          if (countdownTopbarFill) countdownTopbarFill.style.width = '0%';
          if (isInSpeakFirstMode && currentWord) {
            updateDisplayUpper(currentWord);
            addToHistory(currentWord);
            isInSpeakFirstMode = false;
          }
        } else {
          const progress = elapsedTime / totalDuration;
          const offset = circumference - (progress * circumference);
          progressCircle.style.strokeDashoffset = offset;
          const secondsLeft = Math.ceil((totalDuration - elapsedTime) / 1000);
          countdownTextEl.textContent = `${secondsLeft}s`;
          if (countdownTopbarFill) countdownTopbarFill.style.width = `${Math.max(0, (1 - progress) * 100)}%`;
        }
      }, 50);
    }

    function updateHistoryList() {
      const historyList = document.getElementById("historyList");
      historyList.innerHTML = "";
      if (displayHistory.length === 0) return;
      displayHistory.forEach(item => {
        const historyItem = document.createElement("div");
        historyItem.className = "history-item";
        historyItem.textContent = item;
        historyList.appendChild(historyItem);
      });
      historyList.scrollTop = historyList.scrollHeight;
    }

    function addToHistory(word) {
      const modeNow = getSelectedStudyMode();
      const isArticles = (modeNow === 'articlesIndef' || modeNow === 'articlesDef');
      const indexNum = isArticles ? prefixIndex : currentIndex;
      const historyEntry = `${indexNum}: ${word}`;
      if (!displayHistory.includes(historyEntry)) {
        displayHistory.push(historyEntry);
        updateHistoryList();
      }
    }

    async function nextWord() {
      if (!words.length) return;
      // Articles mode branch (le/la or un/une)
      if (getSelectedStudyMode() === 'articlesIndef' || getSelectedStudyMode() === 'articlesDef') {
        prefixWords = (getSelectedStudyMode() === 'articlesIndef') ? prefixWordsIndef : prefixWordsDef;
        window.prefixOriginalOrder = (getSelectedStudyMode() === 'articlesIndef') ? window.prefixOriginalOrderIndef : window.prefixOriginalOrderDef;
        if (prefixWords.length === 0) return;
        // If previous question existed and was not answered, record as unanswered
        if (currentBaseWord && !privativeAnswered) {
          addToHistory(`‚Ä¶ ${currentBaseWord}`);
        }
        if (prefixIndex >= prefixWords.length) {
          // Restart automatically for privative quiz
          showToast(i18n[curLang].restart_message);
          // Clear Answers modal/history on restart
          displayHistory = [];
          updateHistoryList();
          prefixIndex = 0;
          if (shuffleEnabled) shuffleArray(prefixWords); else if (window.prefixOriginalOrder) prefixWords = [...window.prefixOriginalOrder];
          setTimeout(() => nextWord(), 0);
          return;
        }
        const item = prefixWords[prefixIndex];
        currentWord = item.full;
        currentBaseWord = item.base;
        currentExpectedPrefix = item.prefix;
        privativeAnswered = false;
        prefixIndex++;
        updateProgressBar();
        // Display placeholder for prefix
        updateDisplayUpper(`‚Ä¶ ${currentBaseWord}`);
        // Speak base word only
        await speakWord(currentBaseWord);
        updateStatusInfo(i18n[curLang].status_word_progress.replace('{current}', prefixIndex).replace('{total}', prefixWords.length));
        return;
      }
      // For Listen & Repeat: add the previously spoken word to Answers when advancing
      if (!isSessionComplete && getSelectedStudyMode() === 'listenThenRepeat' && currentWord) {
        addToHistory(currentWord);
      }
      if (isSessionComplete) {
        if (shuffleEnabled) shuffleArray(words);
        initializeStudy();
        return;
      }

      if (currentIndex >= words.length) {
        isSessionComplete = true;
        updateDisplayUpper(i18n[curLang].session_complete, true);
        updateInstruction('');
        nextBtn.textContent = i18n[curLang].start_next_session;
        updateProgressBar();
        ['repeatBtn', 'showBtn', 'voiceBtn'].forEach(id => document.getElementById(id).disabled = true);
        return;
      }

      // Handle staged flow for Read & Say: if we are in stages 1 or 2
      if (getSelectedStudyMode() === 'readThenSay' && currentWord) {
        if (readSayStage === 1) {
          await speakWord(currentWord); // speak after the student reads
          updateInstruction(i18n[curLang].instr_skip_next);
          readSayStage = 2;
          return; // wait for another Next to advance
        } else if (readSayStage === 2) {
          // proceed to pick the next word
          readSayStage = 0;
        }
      }

      // Handle staged flow for Listen then Repeat
      if (getSelectedStudyMode() === 'listenThenRepeat' && currentWord) {
        if (listenRepeatStage === 1) {
          // Reveal the word after the student repeats and speak it once more
          updateDisplayUpper(currentWord);
          await speakWord(currentWord);
          updateInstruction(i18n[curLang].instr_skip_next);
          listenRepeatStage = 2; // wait for next press to advance (pre-add will log previous)
          return;
        } else if (listenRepeatStage === 2) {
          // proceed to pick the next word
          listenRepeatStage = 0;
        }
      }

      currentWord = words[currentIndex];
      currentIndex++;
      updateProgressBar();

      studyMode = getSelectedStudyMode();

      if (studyMode === "listenRead") {
        updateDisplayUpper(currentWord);
        addToHistory(currentWord);
        updateInstruction('');
        await speakWord(currentWord);
      } else if (studyMode === "readThenSay") {
        // Stage 1: show the word, wait for student to say it
        updateDisplayUpper(currentWord);
        addToHistory(currentWord);
        updateInstruction(i18n[curLang].instr_read_say);
        readSayStage = 1; // next press will speak
        updateStatusInfo(i18n[curLang].status_word_progress.replace('{current}', currentIndex).replace('{total}', words.length));
        return;
      } else if (studyMode === "listenThenRepeat") {
        updateDisplayUpper(i18n[curLang].reveal_prompt);
        updateInstruction(i18n[curLang].instr_listen);
        await speakWord(currentWord); // speak first
        updateInstruction(i18n[curLang].instr_repeat);
        listenRepeatStage = 1; // now wait for user to reveal
        return;
      }
      updateStatusInfo(i18n[curLang].status_word_progress.replace('{current}', currentIndex).replace('{total}', words.length));
    }

    async function repeatWord() { 
      if (!currentWord) return; 
      if ((getSelectedStudyMode() === 'articlesIndef' || getSelectedStudyMode() === 'articlesDef') && currentBaseWord) {
        await speakWord(currentBaseWord);
      } else {
        await speakWord(currentWord);
      }
    }

    function showCurrentWord() {
      if (currentWord) {
        if ((getSelectedStudyMode() === 'articlesIndef' || getSelectedStudyMode() === 'articlesDef') && currentBaseWord) {
          const full = `${currentExpectedPrefix} ${currentBaseWord}`;
          updateDisplayUpper(full);
          addToHistory(full);
          // Speak the full phrase when revealed via Show
          speakWord(full);
          privativeAnswered = true;
          return;
        }
        updateDisplayUpper(currentWord);
        isInSpeakFirstMode = false;
        addToHistory(currentWord);
      }
    }

    function toggleVoice() {
      const vs = document.getElementById("voiceSelect");
      if (vs.options.length === 0) return;
      vs.selectedIndex = (vs.selectedIndex + 1) % vs.options.length;
      currentVoice = vs.value;
      try { localStorage.setItem('selectedVoice', currentVoice); } catch (_) {}
      updateVoiceIndicator();
      renderVoiceDebug();
    }
    
    // --- UI UPDATE & MANAGEMENT FUNCTIONS ---
    function updateProgressBar() {
        let progress = 0;
        const modeNow = getSelectedStudyMode();
        if (modeNow === 'articlesIndef' || modeNow === 'articlesDef') {
          const active = (modeNow === 'articlesIndef') ? prefixWordsIndef : prefixWordsDef;
          progress = active.length > 0 ? (prefixIndex / active.length) * 100 : 0;
        } else {
          progress = words.length > 0 ? (currentIndex / words.length) * 100 : 0;
        }
        progressBarFill.style.width = `${progress}%`;
    }

    function updateVoiceIndicator() {
        const vs = document.getElementById('voiceSelect');
        const selectedOption = vs.selectedOptions[0];
        const bottomVoice = document.getElementById('bottomVoice');
        const settingsVoiceValue = document.getElementById('settingsVoiceValue');
        if (!selectedOption) { 
          document.getElementById('activeVoiceDisplay').textContent = i18n[curLang].no_voices; 
          if (bottomVoice) bottomVoice.textContent = i18n[curLang].no_voices; 
          if (settingsVoiceValue) settingsVoiceValue.textContent = '‚Äî';
          return; 
        }
        // If "system" is selected, try to show the resolved best French voice name
        if (selectedOption.value === 'system') {
          const resolved = bestFrenchVoice();
          if (resolved) {
            document.getElementById('activeVoiceDisplay').textContent = `üó£Ô∏è ${resolved.name} (${resolved.lang})`;
            if (bottomVoice) bottomVoice.textContent = `${resolved.name} (${resolved.lang})`;
            if (settingsVoiceValue) settingsVoiceValue.textContent = `${resolved.name}`;
            return;
          }
        }
        document.getElementById('activeVoiceDisplay').textContent = `üó£Ô∏è ${selectedOption.text}`;
        if (bottomVoice) bottomVoice.textContent = selectedOption.text;
        if (settingsVoiceValue) settingsVoiceValue.textContent = selectedOption.text;
    }

    function getSelectedStudyMode() {
      const sel = document.getElementById('studyModeSelect');
      if (sel) return sel.value;
      // Fallback to legacy radios if present
      const radio = document.querySelector('input[name="studyMode"]:checked');
      return radio ? radio.value : 'listenThenRepeat';
    }

    function updateStudyModeIndicator() {
      const sel = document.getElementById('studyModeSelect');
      const text = (sel && sel.selectedOptions && sel.selectedOptions[0]) ? sel.selectedOptions[0].text : '';
      document.getElementById('activeStudyModeDisplay').textContent = `${i18n[curLang].indicator_mode_prefix} ${text}`;
      const bottomMode = document.getElementById('bottomMode'); if (bottomMode) bottomMode.textContent = text;
      const settingsModeValue = document.getElementById('settingsModeValue'); if (settingsModeValue) settingsModeValue.textContent = text || settingsModeValue.textContent;
    }

    function updateShuffleIndicator() {
      document.getElementById('activeShuffleDisplay').textContent = shuffleEnabled ? i18n[curLang].indicator_shuffle_on : i18n[curLang].indicator_shuffle_off;
      const bottomShuffle = document.getElementById('bottomShuffle');
      if (bottomShuffle) {
        bottomShuffle.textContent = 'üîÄ';
        bottomShuffle.classList.toggle('off', !shuffleEnabled);
      }
    }

    function updateAllIndicators() {
      updateVoiceIndicator();
      updateStudyModeIndicator();
      updateShuffleIndicator();
    }
    
    // --- Voice Debug Helper (feature-flagged) ---
    function isVoiceDebugEnabled() {
      try {
        const hash = (location.hash || '').toLowerCase();
        if (hash.includes('voicedebug')) return true;
      } catch (_) {}
      try {
        const params = new URLSearchParams(location.search || '');
        if (params.has('voicedebug')) {
          const val = (params.get('voicedebug') || '').toLowerCase();
          if (val === '' || val === '1' || val === 'true' || val === 'yes') return true;
        }
      } catch (_) {}
      try { return localStorage.getItem('voiceDebug') === '1'; } catch (_) { return false; }
    }

    function ensureVoiceDebugEl() {
      let el = document.getElementById('voiceDebug');
      if (!el) {
        const host = document.getElementById('bottomStatus') || document.body;
        el = document.createElement('div');
        el.id = 'voiceDebug';
        el.className = '';
        el.style.opacity = '0.7';
        el.style.fontSize = '0.85em';
        host.appendChild(el);
      }
      return el;
    }

    function renderVoiceDebug() {
      const enabled = isVoiceDebugEnabled();
      const el = ensureVoiceDebugEl();
      if (!enabled) { el.style.display = 'none'; return; }

      // Gather info
      const all = Array.isArray(availableVoices) ? availableVoices : [];
      const fr = all.filter(v => (v.lang || '').toLowerCase().startsWith('fr'));
      const engine = isSafari ? 'Safari' : (isChromium ? 'Chromium' : (isFirefox ? 'Firefox' : 'Other'));
      const vs = document.getElementById('voiceSelect');
      const selectedVal = (vs && vs.value) ? vs.value : currentVoice || 'system';
      let selectedText = 'System';
      if (vs && vs.selectedOptions && vs.selectedOptions[0]) {
        selectedText = vs.selectedOptions[0].value === 'system' ? 'System' : vs.selectedOptions[0].text;
      } else if (selectedVal && selectedVal !== 'system') {
        const vo = fr.find(v => v.name === selectedVal);
        selectedText = vo ? `${vo.name} (${vo.lang})` : selectedVal;
      }
      const best = bestFrenchVoice();
      const resolvedText = best ? `${best.name} (${best.lang})` : '‚Äî';

      el.textContent = `Voice Debug ‚Äî Selected: ${selectedText} | Resolved: ${resolvedText} | Engine: ${engine} | FR: ${fr.length}/${all.length}`;
      el.style.display = 'block';
    }

    // Expose toggles for convenience during testing
    window.enableVoiceDebug = function() { try { localStorage.setItem('voiceDebug', '1'); } catch (_) {} renderVoiceDebug(); };
    window.disableVoiceDebug = function() { try { localStorage.removeItem('voiceDebug'); } catch (_) {} renderVoiceDebug(); };
    
    function generateWordListsUI() {
        const containers = [
          { container: document.getElementById('wordListsOptions'), section: document.getElementById('wordListsSection'), style: 'legacy' },
          { container: document.getElementById('menuWordListsOptions'), section: document.getElementById('menuWordListsSection'), style: 'ios' },
        ];
        containers.forEach(({container, section}) => { if (container) container.innerHTML = ''; });
        const filenames = Object.keys(wordLists);
        containers.forEach(({container, section, style}) => {
          if (!container || !section) return;
          if (filenames.length > 1) {
              section.style.display = 'block';
              filenames.forEach(name => {
                  if (style === 'ios') {
                    const row = document.createElement('div');
                    row.className = 'settings-item';
                    const label = document.createElement('div');
                    label.className = 'settings-label';
                    label.textContent = name;
                    const summary = document.createElement('div');
                    summary.className = 'subtle';
                    summary.style.marginRight = '12px';
                    summary.textContent = `${wordLists[name].words.length} ${i18n[curLang].words_lower}`;
                    const toggle = document.createElement('input');
                    toggle.type = 'checkbox';
                    toggle.className = 'ios-switch';
                    toggle.checked = !!wordLists[name].enabled;
                    toggle.dataset.filename = name;
                    toggle.addEventListener('change', () => {
                      confirmationCallback = () => {
                        wordLists[name].enabled = toggle.checked;
                        rebuildActiveWordsList();
                      };
                      const ctext = document.getElementById('confirmationDialogText');
                      if (ctext) ctext.textContent = i18n[curLang].confirm_word_list;
                      confirmationDialog.classList.add('visible');
                    });
                    row.appendChild(label);
                    row.appendChild(summary);
                    row.appendChild(toggle);
                    container.appendChild(row);
                  } else {
                    const item = document.createElement('div');
                    item.className = 'mode-option';
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = wordLists[name].enabled;
                    checkbox.id = `file--${name}`;
                    checkbox.dataset.filename = name;
                    checkbox.addEventListener('change', () => {
                        confirmationCallback = () => {
                            wordLists[name].enabled = checkbox.checked;
                            rebuildActiveWordsList();
                        };
                        document.getElementById('confirmationDialogText').textContent = i18n[curLang].confirm_word_list;
                        confirmationDialog.classList.add('visible');
                    });
                    const label = document.createElement('label');
                    label.htmlFor = `file--${name}`;
                    label.textContent = `${name} (${wordLists[name].words.length} ${i18n[curLang].words_lower})`;
                    item.appendChild(checkbox);
                    item.appendChild(label);
                    container.appendChild(item);
                  }
              });
          } else {
              section.style.display = 'none';
          }
        });
    }

    function rebuildActiveWordsList() {
        let newWordList = [];
        let fileCount = 0;
        for(const filename in wordLists) {
            if(wordLists[filename].enabled) {
                newWordList = newWordList.concat(wordLists[filename].words);
                fileCount++;
            }
        }
        // Update grouped settings count if present
        const activeCountEl = document.getElementById('settingsActiveListsCount');
        if (activeCountEl) activeCountEl.textContent = String(fileCount);
        words = newWordList;
        originalWordOrder = [...words]; // Update original order for unshuffling
        const bottomIcon = document.getElementById('bottomFileStatus');
        if (bottomIcon) {
          if (words.length > 0) {
            bottomIcon.textContent = '‚úÖ';
            bottomIcon.classList.remove('status-alert');
            bottomIcon.classList.add('status-ok');
          } else {
            bottomIcon.textContent = '‚ùå';
            bottomIcon.classList.remove('status-ok');
            bottomIcon.classList.add('status-alert');
          }
        }
        // Build articles pools (indef: un/une, def: le/la)
        const indepPattern = /^(un|une)[\s-]+(.+)$/i;
        const defPattern = /^(le|la)[\s-]+(.+)$/i;
        prefixWordsIndef = words
          .map(w => w.trim())
          .filter(Boolean)
          .filter(w => indepPattern.test(w))
          .map(w => { const m = w.match(indepPattern); return { full: w, prefix: m[1].toLowerCase(), base: m[2].trim() }; });
        prefixWordsDef = words
          .map(w => w.trim())
          .filter(Boolean)
          .filter(w => defPattern.test(w))
          .map(w => { const m = w.match(defPattern); return { full: w, prefix: m[1].toLowerCase(), base: m[2].trim() }; });
        window.prefixOriginalOrderIndef = [...prefixWordsIndef];
        window.prefixOriginalOrderDef = [...prefixWordsDef];
        // Enable/disable articles options in dropdown
        const sel = document.getElementById('studyModeSelect');
        if (sel) {
          const hasIndef = prefixWordsIndef.length > 0;
          const hasDef = prefixWordsDef.length > 0;
          const optIndef = sel.querySelector('option[value="articlesIndef"]');
          const optDef = sel.querySelector('option[value="articlesDef"]');
          if (optIndef) optIndef.disabled = !hasIndef;
          if (optDef) optDef.disabled = !hasDef;
          if (sel.value === 'articlesIndef' && !hasIndef) sel.value = 'listenThenRepeat';
          if (sel.value === 'articlesDef' && !hasDef) sel.value = 'listenThenRepeat';
        }
        initializeStudy();
    }

    function showToast(message, duration = 3000) {
        toastNotification.textContent = message;
        toastNotification.classList.add('visible');
        setTimeout(() => {
            toastNotification.classList.remove('visible');
        }, duration);
    }

    function updateDisplayUpper(t, isComplete = false) { 
        const el = document.getElementById("displayAreaUpper");
        el.textContent = t;
        el.classList.toggle('session-complete-message', isComplete);
    }
    function updateInstruction(t='') {
        const el = document.getElementById('displayInstruction');
        if (el) el.textContent = t || '';
    }
    function updateStatusInfo(m) { 
        const el = document.getElementById("statusInfo");
        if (!el) return;
        // Do not print the generic ready/empty prompts; keep bottom bar compact
        if (!m || m === i18n[curLang].ready_to_start || m === i18n[curLang].status_load_prompt) {
          el.textContent = '';
          return;
        }
        el.textContent = m; 
        el.classList.remove('status-ok','status-alert');
    }
    
    // --- EVENT LISTENERS ---
    // Modals
    function primeVoices() {
      try {
        const u = new SpeechSynthesisUtterance(' ');
        u.lang = 'fr-FR';
        u.volume = 0; // silent
        u.rate = 0.1;
        u.onend = () => setTimeout(populateVoiceList, 0);
        synth.speak(u);
      } catch (_) { /* no-op */ }
    }

    document.getElementById('settingsBtn').addEventListener('click', () => { 
      // Open Menu for one-click access to controls
      menuModal.classList.add('visible');
      document.getElementById('menuBtn')?.setAttribute('aria-expanded','true');
      if (isSafari) primeVoices();
      populateVoiceList();
      const mc = menuModal.querySelector('.modal-content'); if (mc) mc.focus();
    });
    // Language flags
    const langEnEl = document.getElementById('langEn');
    const langFrEl = document.getElementById('langFr');
    if (langEnEl) langEnEl.addEventListener('click', () => setLanguage('en'));
    if (langFrEl) langFrEl.addEventListener('click', () => setLanguage('fr'));

    // Primary controls
    if (nextBtn) nextBtn.addEventListener('click', () => { if (!nextBtn.disabled) nextWord(); });
    if (repeatBtn) repeatBtn.addEventListener('click', () => { if (!repeatBtn.disabled) repeatWord(); });
    if (showBtn) showBtn.addEventListener('click', () => { if (!showBtn.disabled) showCurrentWord(); });
    if (voiceBtn) voiceBtn.addEventListener('click', () => { if (!voiceBtn.disabled) toggleVoice(); });
    document.getElementById('helpBtn').addEventListener('click', () => { helpModal.classList.add('visible'); const mc = helpModal.querySelector('.modal-content'); if (mc) mc.focus(); });
    // Hamburger menu
    const menuModal = document.getElementById('menuModal');
    const menuBtn = document.getElementById('menuBtn');
    if (menuBtn) menuBtn.addEventListener('click', () => { 
      if (menuModal) { 
        menuModal.classList.add('visible'); 
        menuBtn.setAttribute('aria-expanded','true'); 
        bodyScrollLock(true);
        // Sync grouped UI controls on open
        const st = document.getElementById('shuffleToggle'); if (st) st.checked = shuffleEnabled;
        updateAllIndicators();
        const closeOverlay = document.getElementById('menuCloseOverlay');
        if (closeOverlay) {
          const rect = menuBtn.getBoundingClientRect();
          closeOverlay.style.top = `${rect.top}px`;
          closeOverlay.style.left = `${rect.left}px`;
          closeOverlay.style.width = `${rect.width}px`;
          closeOverlay.style.height = `${rect.height}px`;
          closeOverlay.style.display = 'block';
        }
        openMenuPanel({ target: menuBtn });
        const mc = menuModal.querySelector('.modal-content'); if (mc) mc.focus(); 
      }
    });
    const menuCloseOverlay = document.getElementById('menuCloseOverlay');
    if (menuCloseOverlay) menuCloseOverlay.addEventListener('click', () => { 
      menuModal.classList.remove('visible'); 
      menuBtn.setAttribute('aria-expanded','false'); 
      menuCloseOverlay.style.display = 'none';
      const mp = document.getElementById('menuPanel'); if (mp) mp.setAttribute('aria-hidden','true');
      bodyScrollLock(false);
    });
    const menuLangEn = document.getElementById('menuLangEn');
    const menuLangFr = document.getElementById('menuLangFr');
    if (menuLangEn) menuLangEn.addEventListener('click', () => { setLanguage('en'); });
    if (menuLangFr) menuLangFr.addEventListener('click', () => { setLanguage('fr'); });
    // Row navigation to subpanels
    function openSubpanel(id){ const el=document.getElementById(id); if(!el) return; el.setAttribute('aria-hidden','false'); const mp=document.getElementById('menuPanel'); if(mp) mp.classList.add('sub-open'); }
    function closeSubpanel(id){ const el=document.getElementById(id); if(!el) return; el.setAttribute('aria-hidden','true'); const mp=document.getElementById('menuPanel'); if(mp){ const anyOpen=Array.from(document.querySelectorAll('#menuModal .subpanel')).some(sp=>sp.getAttribute('aria-hidden')==='false'); if(!anyOpen) mp.classList.remove('sub-open'); } }
    const rowLanguage = document.getElementById('rowLanguage'); if(rowLanguage){ const fn=()=>{ openSubpanel('langPanel'); updateLangChecks(); }; rowLanguage.addEventListener('click', fn); rowLanguage.addEventListener('keydown', e=>{ if(e.key==='Enter' || e.key===' ') { e.preventDefault(); fn(); } }); }
    const rowEleven = document.getElementById('rowEleven'); if(rowEleven){ const fn=()=>openSubpanel('elevenPanel'); rowEleven.addEventListener('click', fn); rowEleven.addEventListener('keydown', e=>{ if(e.key==='Enter' || e.key===' ') { e.preventDefault(); fn(); } }); }
    const rowOpenAI = document.getElementById('rowOpenAI'); if(rowOpenAI){ const fn=()=>openSubpanel('openaiPanel'); rowOpenAI.addEventListener('click', fn); rowOpenAI.addEventListener('keydown', e=>{ if(e.key==='Enter' || e.key===' ') { e.preventDefault(); fn(); } }); }
    const rowFiles = document.getElementById('rowFiles'); if(rowFiles){ const fn=()=>{ openSubpanel('filesPanel'); generateWordListsUI(); }; rowFiles.addEventListener('click', fn); rowFiles.addEventListener('keydown', e=>{ if(e.key==='Enter' || e.key===' ') { e.preventDefault(); fn(); } }); }
    // Back buttons
    document.querySelectorAll('.panel-back').forEach(btn=>{ btn.addEventListener('click',()=>{ const id=btn.getAttribute('data-back'); if(id) closeSubpanel(id); }); });
    // Language sheet handlers
    function updateLangChecks(){ const en=document.getElementById('langCheckEn'); const fr=document.getElementById('langCheckFr'); if(en&&fr){ en.style.display = (curLang==='en')?'block':'none'; fr.style.display = (curLang==='fr')?'block':'none'; } }
    const langOptionEn = document.getElementById('langOptionEn'); if(langOptionEn){ langOptionEn.addEventListener('click',()=>{ setLanguage('en'); updateLangChecks(); closeSubpanel('langPanel'); }); }
    const langOptionFr = document.getElementById('langOptionFr'); if(langOptionFr){ langOptionFr.addEventListener('click',()=>{ setLanguage('fr'); updateLangChecks(); closeSubpanel('langPanel'); }); }

    // No action sheets; direct file selectors handled below

    // Files: Add Word List button triggers hidden input
    const btnAddWordList=document.getElementById('btnAddWordList'); const fileInputEl=document.getElementById('menuFileInput'); if(btnAddWordList && fileInputEl){ btnAddWordList.addEventListener('click',()=>fileInputEl.click()); }
    const menuHelpBtn = document.getElementById('menuHelpBtn');
    if (menuHelpBtn) menuHelpBtn.addEventListener('click', () => { menuModal.classList.remove('visible'); helpModal.classList.add('visible'); const mc = helpModal.querySelector('.modal-content'); if (mc) mc.focus(); });
    const menuSettingsBtn = document.getElementById('menuSettingsBtn');
    if (menuSettingsBtn) menuSettingsBtn.addEventListener('click', () => { menuModal.classList.remove('visible'); settingsModal.classList.add('visible'); if (isSafari) primeVoices(); populateVoiceList(); const mc = settingsModal.querySelector('.modal-content'); if (mc) mc.focus(); });
    // Left-rail expanding panel behavior
    const menuPanel = document.getElementById('menuPanel');
    let menuLastTrigger = null;
    function isReducedMotion() { return window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches; }
    function bodyScrollLock(on) { document.body.style.overflow = on ? 'hidden' : ''; }
    function getFocusableElements(root) { return Array.from(root.querySelectorAll('a, button, input, select, textarea, [tabindex]:not([tabindex="-1"])')).filter(el => !el.disabled && el.offsetParent !== null); }
    function openMenuPanel(trigger) {
      if (!menuPanel) return;
      if (trigger && trigger.target) menuLastTrigger = trigger.target;
      menuPanel.setAttribute('aria-hidden','false');
      const els = getFocusableElements(menuPanel);
      if (els[0]) els[0].focus();
    }
    function closeMenuPanel() {
      if (!menuPanel) return;
      menuPanel.setAttribute('aria-hidden','true');
      if (menuLastTrigger && typeof menuLastTrigger.focus === 'function') menuLastTrigger.focus();
    }
    function toggleMenuPanel() {
      if (!menuPanel) return;
      const open = menuPanel.getAttribute('aria-hidden') === 'false';
      if (open) closeMenuPanel(); else openMenuPanel();
    }
    // Directly open the panel (no rail)
    const menuPanelClose = menuPanel ? menuPanel.querySelector('.close-btn') : null;
    if (menuPanelClose) menuPanelClose.addEventListener('click', closeMenuPanel);
    // Alt+M shortcut
    document.addEventListener('keydown', e => {
      if (e.altKey && (e.key === 'm' || e.key === 'M')) { e.preventDefault(); if (!menuModal.classList.contains('visible')) { menuModal.classList.add('visible'); menuBtn?.setAttribute('aria-expanded','true'); bodyScrollLock(true); openMenuPanel(); } else { toggleMenuPanel(); } }
    });
    
    historyBtn.addEventListener('click', () => {
        historyModalContent.innerHTML = ""; // Clear previous content
        if (displayHistory.length === 0) {
            historyModalContent.textContent = i18n[curLang].history_empty;
        } else {
            displayHistory.forEach(item => {
                const historyItem = document.createElement("div");
                historyItem.className = "history-item";
                historyItem.textContent = item;
                historyModalContent.appendChild(historyItem);
            });
        }
        historyModal.classList.add('visible');
        const mc = historyModal.querySelector('.modal-content'); if (mc) mc.focus();
    });

    const wordListContent = document.getElementById("wordListContent");
    document.getElementById('viewListBtn').addEventListener('click', () => {
        wordListContent.innerHTML = "";
        words.forEach((word, index) => {
            const wordItem = document.createElement("div");
            wordItem.className = "history-item";
            wordItem.textContent = `${index + 1}. ${word}`;
            if (index === currentIndex - 1) wordItem.style.fontWeight = "bold";
            wordListContent.appendChild(wordItem);
        });
        wordListModal.classList.add('visible');
        const mc2 = wordListModal.querySelector('.modal-content'); if (mc2) mc2.focus();
    });
    
    // Confirmation Dialog & Shuffle Logic
    document.getElementById('shuffleToggle').addEventListener('change', e => {
        e.preventDefault();
        confirmationCallback = () => {
            shuffleEnabled = !shuffleEnabled; 
            document.getElementById('shuffleToggle').checked = shuffleEnabled;
            if (shuffleEnabled) {
              shuffleArray(words);
              if (prefixWords.length > 0) shuffleArray(prefixWords);
            } else {
              words = [...originalWordOrder];
              if (window.prefixOriginalOrder) prefixWords = [...window.prefixOriginalOrder];
            }
            updateShuffleIndicator();
            initializeStudy();
        };
        document.getElementById('confirmationDialogText').textContent = i18n[curLang].confirm_shuffle;
        confirmationDialog.classList.add('visible');
    });

    document.getElementById('confirmReset').addEventListener('click', () => {
        if (confirmationCallback) confirmationCallback();
        confirmationDialog.classList.remove('visible');
        confirmationCallback = null;
    });
    document.getElementById('cancelReset').addEventListener('click', () => {
        // Revert UI change if action is cancelled
        generateWordListsUI();
        document.getElementById('shuffleToggle').checked = shuffleEnabled;
        confirmationDialog.classList.remove('visible');
        confirmationCallback = null;
    });

    // File Loading
    const fileInput = document.createElement('input');
    fileInput.type = 'file'; fileInput.accept = '.txt'; fileInput.multiple = true;
    
    fileInput.addEventListener('change', e => {
      if (e.target.files && e.target.files.length > 0) {
        handleFileLoad(Array.from(e.target.files));
      }
    });

    if (!isIOS) {
      const addBtn = document.getElementById('welcomeAddBtn'); if (addBtn) addBtn.addEventListener('click', () => fileInput.click());
    } else {
      const iosPickerRow = document.getElementById('iosFilePickerRow');
      const iosFileInput = document.getElementById('iosFileInput');
      // Keep the native input hidden but clickable via our button; show row only if needed
      const addBtn = document.getElementById('welcomeAddBtn');
      if (addBtn && iosFileInput) addBtn.addEventListener('click', () => iosFileInput.click());
      if (iosFileInput) {
        iosFileInput.addEventListener('change', e => {
          if (e.target.files && e.target.files.length > 0) {
            handleFileLoad(Array.from(e.target.files));
          }
        });
      }
    }
    function isFileDrag(e) {
      try {
        if (!e.dataTransfer) return false;
        if (e.dataTransfer.files && e.dataTransfer.files.length) return true;
        if (e.dataTransfer.types && typeof e.dataTransfer.types.includes === 'function') {
          return e.dataTransfer.types.includes('Files');
        }
      } catch (_) { }
      return false;
    }
    document.body.addEventListener("dragover", e => { if (isFileDrag(e)) { e.preventDefault(); e.stopPropagation(); } });
    document.body.addEventListener("drop", e => {
      if (!isFileDrag(e)) return;
      e.preventDefault(); e.stopPropagation();
      const files = Array.from(e.dataTransfer.files).filter(f => f.name.endsWith('.txt'));
      if (files.length > 0) handleFileLoad(files);
    });
    // Menu file input handler
    (function(){
      const menuFileInput = document.getElementById('menuFileInput');
      if (menuFileInput) menuFileInput.addEventListener('change', (e) => {
        const files = Array.from(e.target.files || []).filter(f => f.name.endsWith('.txt'));
        if (files.length > 0) handleFileLoad(files);
        e.target.value = '';
      });
    })();
    
    document.getElementById('historyToggleBtn').addEventListener('click', () => document.querySelector('.container').classList.toggle('history-hidden'));

    // Keyboard Shortcuts & Modal Closing
    document.addEventListener("keydown", e => {
      if (e.key === 'Escape') { 
        allModals.forEach(modal => modal.classList.remove('visible'));
        document.getElementById('menuBtn')?.setAttribute('aria-expanded','false');
        const mco = document.getElementById('menuCloseOverlay'); if (mco) mco.style.display = 'none';
        const mp = document.getElementById('menuPanel'); if (mp) mp.setAttribute('aria-hidden','true');
        bodyScrollLock(false);
      }
      if (e.target.tagName.toLowerCase() === 'input' || document.querySelector('.modal.visible')) return;
      const btnId = { ' ': 'nextBtn', 'r': 'repeatBtn', 's': 'showBtn', 'v': 'voiceBtn' }[e.key.toLowerCase()];
      if (btnId && !e.metaKey && !e.ctrlKey && !e.altKey) {
        e.preventDefault();
        const btn = document.getElementById(btnId);
        if(btn && !btn.disabled) btn.click();
      }
    });
    
    allModals.forEach(modal => {
        modal.addEventListener('click', e => { 
          if (e.target === modal) { 
            modal.classList.remove('visible'); 
            if (modal.id === 'menuModal') { 
              document.getElementById('menuBtn')?.setAttribute('aria-expanded','false');
              const mco = document.getElementById('menuCloseOverlay'); if (mco) mco.style.display = 'none';
              // Ensure panel is reset and scrolling unlocked
              const mp = document.getElementById('menuPanel'); if (mp) mp.setAttribute('aria-hidden','true');
              bodyScrollLock(false);
            }
          }
        });
        const closeBtn = modal.querySelector('.close-btn');
        if(closeBtn) closeBtn.addEventListener('click', () => { 
          modal.classList.remove('visible'); 
          if (modal.id === 'menuModal') { 
            document.getElementById('menuBtn')?.setAttribute('aria-expanded','false');
            const mco = document.getElementById('menuCloseOverlay'); if (mco) mco.style.display = 'none';
            const mp = document.getElementById('menuPanel'); if (mp) mp.setAttribute('aria-hidden','true');
            bodyScrollLock(false);
          }
        });
    });
    // Articles/Privative controls handlers
    const unBtn = document.getElementById('prefixUnBtn');
    const uneBtn = document.getElementById('prefixUneBtn');
    if (unBtn) unBtn.addEventListener('click', () => {
      if (!currentBaseWord) return;
      const mode = getSelectedStudyMode();
      const choice = (mode === 'articlesDef') ? 'le' : 'un';
      const correct = currentExpectedPrefix === choice;
      const msg = (correct ? i18n[curLang].toast_correct_prefix : i18n[curLang].toast_wrong_prefix)
        .replace('{prefix}', currentExpectedPrefix)
        .replace('{base}', currentBaseWord);
      showToast(msg);
      updateDisplayUpper(`${currentExpectedPrefix} ${currentBaseWord}`);
      addToHistory(`${currentExpectedPrefix} ${currentBaseWord}`);
      // Speak the full phrase after answer provided
      speakWord(`${currentExpectedPrefix} ${currentBaseWord}`);
      privativeAnswered = true;
    });
    if (uneBtn) uneBtn.addEventListener('click', () => {
      if (!currentBaseWord) return;
      const mode = getSelectedStudyMode();
      const choice = (mode === 'articlesDef') ? 'la' : 'une';
      const correct = currentExpectedPrefix === choice;
      const msg = (correct ? i18n[curLang].toast_correct_prefix : i18n[curLang].toast_wrong_prefix)
        .replace('{prefix}', currentExpectedPrefix)
        .replace('{base}', currentBaseWord);
      showToast(msg);
      updateDisplayUpper(`${currentExpectedPrefix} ${currentBaseWord}`);
      addToHistory(`${currentExpectedPrefix} ${currentBaseWord}`);
      // Speak the full phrase after answer provided
      speakWord(`${currentExpectedPrefix} ${currentBaseWord}`);
      privativeAnswered = true;
    });
    
    document.getElementById('voiceSelect').addEventListener('change', e => { 
      currentVoice = e.target.value; 
      try { localStorage.setItem('selectedVoice', currentVoice); } catch (_) {}
      updateVoiceIndicator(); 
      renderVoiceDebug();
    });
    document.getElementById('voiceSelect').addEventListener('focus', populateVoiceList);
    const voiceTestBtn = document.getElementById('voiceTestBtn');
    if (voiceTestBtn) voiceTestBtn.addEventListener('click', () => { speakWord(i18n[curLang].test_phrase); });
    // ElevenLabs API key handlers
    function isValidElevenKey(k) { return typeof k === 'string' && /^sk_[A-Za-z0-9]{8,}/.test(k); }
    function isValidOpenAIKey(k) { return typeof k === 'string' && /^sk-proj-[A-Za-z0-9_-]{8,}/.test(k); }
    function setElevenKey(k) {
      const v = (k || '').trim();
      if (v && !isValidElevenKey(v)) { showToast('Invalid ElevenLabs key format'); return; }
      elevenKey = v;
      try { if (elevenKey) localStorage.setItem('eleven_api_key', elevenKey); else localStorage.removeItem('eleven_api_key'); } catch(_) {}
      window._ELEVEN = window._ELEVEN || {}; window._ELEVEN.key = elevenKey;
      const m = document.getElementById('elevenKeyMasked'); if (m) m.textContent = elevenKey ? ('Key: ' + (elevenKey.length>16 ? (elevenKey.slice(0,10)+'‚Ä¶'+elevenKey.slice(-6)) : elevenKey.replace(/.(?=.{4})/g,'‚Ä¢'))) : 'No key set';
      populateVoiceList();
      updateIntegrationIndicators();
    }
    try {
      const savedEl = localStorage.getItem('eleven_api_key');
      if (savedEl) {
        elevenKey = String(savedEl).trim();
        window._ELEVEN = window._ELEVEN || {}; window._ELEVEN.key = elevenKey;
        const m = document.getElementById('elevenKeyMasked'); if (m) m.textContent = 'Key: ' + (elevenKey.length>16 ? (elevenKey.slice(0,10)+'‚Ä¶'+elevenKey.slice(-6)) : elevenKey.replace(/.(?=.{4})/g,'‚Ä¢'));
        populateVoiceList();
        updateIntegrationIndicators();
      }
    } catch(_) {}
    function updateIntegrationIndicators(){
      const elevenOk = typeof elevenKey === 'string' && elevenKey.startsWith('sk_');
      const openaiOk = typeof openaiKey === 'string' && openaiKey.startsWith('sk-proj-');
      const es = document.getElementById('elevenStatus'); if (es) es.textContent = elevenOk ? 'Configured' : '';
      const os = document.getElementById('openaiStatus'); if (os) os.textContent = openaiOk ? 'Configured' : '';
      // Disable/enable fields and file pickers based on state
      const eInput = document.getElementById('elevenKeyInput');
      const eLoad = document.getElementById('elevenLoadFileBtn');
      if (eInput) {
        eInput.disabled = !!elevenOk;
        eInput.value = '';
        eInput.placeholder = elevenOk ? 'Remove ElevenLabs key before load a new one.' : 'Paste a valid API Key';
      }
      if (eLoad) eLoad.classList.toggle('link-disabled', !!elevenOk);
      const oInput = document.getElementById('openaiKeyInput');
      const oLoad = document.getElementById('openaiLoadFileBtn');
      if (oInput) {
        oInput.disabled = !!openaiOk;
        oInput.value = '';
        oInput.placeholder = openaiOk ? 'OpenAI key is loaded. Remove the previous key to load a new one.' : 'Paste a valid API Key';
      }
      if (oLoad) oLoad.classList.toggle('link-disabled', !!openaiOk);
    }
    // Auto-save Eleven key on input (non-empty only)
    (function(){
      const inp = document.getElementById('elevenKeyInput');
      if (inp) {
        const saveIfValue = (hard=false) => { const v = (inp.value||'').trim(); if (!v) return; if (isValidElevenKey(v)) { setElevenKey(v); showToast('ElevenLabs key saved'); } else if (hard) { showToast('Invalid ElevenLabs key format'); } };
        inp.addEventListener('input', () => saveIfValue(false));
        inp.addEventListener('change', () => saveIfValue(true));
        inp.addEventListener('paste', () => setTimeout(()=>saveIfValue(true), 0));
      }
      const clearBtn = document.getElementById('elevenClearBtn');
      if (clearBtn) {
        // Ensure immediate confirmation on desktop by using mousedown to open dialog
        const openConfirm = (e) => {
          e.preventDefault(); e.stopPropagation();
          confirmationCallback = () => { setElevenKey(''); showToast('ElevenLabs key deleted'); updateIntegrationIndicators(); };
          const ctext = document.getElementById('confirmationDialogText'); if (ctext) ctext.textContent = 'Delete ElevenLabs API key?';
          confirmationDialog.classList.add('visible');
        };
        clearBtn.addEventListener('mousedown', openConfirm);
        clearBtn.addEventListener('touchstart', openConfirm, { passive: false });
        // Fallback for keyboard activation
        clearBtn.addEventListener('click', openConfirm);
      }
      const loadBtn = document.getElementById('elevenLoadFileBtn'); const keyFile = document.getElementById('elevenKeyFile');
      if (loadBtn && keyFile) {
        loadBtn.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); keyFile.click(); });
        keyFile.addEventListener('change', () => {
          const f = keyFile.files && keyFile.files[0]; if (!f) return; const r = new FileReader();
          r.onload = () => { const v=String(r.result||'').trim(); if (!v) { keyFile.value=''; return; }
            if (isValidElevenKey(v)) { setElevenKey(v); showToast('ElevenLabs key saved'); } else { showToast('Invalid ElevenLabs key format'); }
            keyFile.value=''; updateIntegrationIndicators(); };
          r.readAsText(f);
        });
      }
    })();
    // OpenAI API key handlers
    function maskKey(k){ if(!k) return ''; return k.length>16 ? (k.slice(0,10)+'‚Ä¶'+k.slice(-6)) : k.replace(/.(?=.{4})/g,'‚Ä¢'); }
    function setOpenAIKey(k){ const v=(k||'').trim(); if(v && !isValidOpenAIKey(v)) { showToast('Invalid OpenAI key format'); return; } openaiKey = v; try{ if(openaiKey) localStorage.setItem('openai_api_key', openaiKey); else localStorage.removeItem('openai_api_key'); }catch(_){}; const m=document.getElementById('openaiKeyMasked'); if(m) m.textContent = openaiKey? ('Key: '+maskKey(openaiKey)) : 'No key set'; populateVoiceList(); updateIntegrationIndicators(); }
    try{ const saved=localStorage.getItem('openai_api_key'); if(saved){ openaiKey=saved; const m=document.getElementById('openaiKeyMasked'); if(m) m.textContent='Key: '+maskKey(openaiKey);} }catch(_){}
    // Initialize integration indicators on load
    updateIntegrationIndicators();
    // Auto-save OpenAI key on input (non-empty only)
    (function(){
      const inp = document.getElementById('openaiKeyInput');
      if (inp) {
        const saveIfValue = (hard=false) => { const v = (inp.value||'').trim(); if (!v) return; if (isValidOpenAIKey(v)) { setOpenAIKey(v); showToast('OpenAI key saved'); } else if (hard) { showToast('Invalid OpenAI key format'); } };
        inp.addEventListener('input', () => saveIfValue(false));
        inp.addEventListener('change', () => saveIfValue(true));
        inp.addEventListener('paste', () => setTimeout(()=>saveIfValue(true), 0));
      }
      const clearBtn = document.getElementById('openaiClearBtn');
      if (clearBtn) clearBtn.addEventListener('click', (e) => {
        e.preventDefault(); e.stopPropagation();
        confirmationCallback = () => { setOpenAIKey(''); showToast('OpenAI key deleted'); updateIntegrationIndicators(); };
        const ctext = document.getElementById('confirmationDialogText'); if (ctext) ctext.textContent = 'Delete OpenAI API key?';
        confirmationDialog.classList.add('visible');
      });
      const loadBtn = document.getElementById('openaiLoadFileBtn'); const keyFile = document.getElementById('openaiKeyFile');
      if (loadBtn && keyFile) {
        loadBtn.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); keyFile.click(); });
        keyFile.addEventListener('change', () => {
          const f = keyFile.files && keyFile.files[0]; if (!f) return; const r = new FileReader();
          r.onload = () => { const v=String(r.result||'').trim(); if (!v) { keyFile.value=''; return; }
            if (isValidOpenAIKey(v)) { setOpenAIKey(v); showToast('OpenAI key saved'); } else { showToast('Invalid OpenAI key format'); }
            keyFile.value=''; updateIntegrationIndicators(); };
          r.readAsText(f);
        });
      }
    })();
    const studyModeSelect = document.getElementById('studyModeSelect');
    if (studyModeSelect) studyModeSelect.addEventListener('change', () => {
      updateStudyModeIndicator();
      const isArticles = (getSelectedStudyMode() === 'articlesIndef' || getSelectedStudyMode() === 'articlesDef');
      document.getElementById('privativeControls').style.display = isArticles ? 'flex' : 'none';
      // Update prefix buttons for selected articles mode
      const unBtnLbl = document.getElementById('prefixUnBtn');
      const uneBtnLbl = document.getElementById('prefixUneBtn');
      if (unBtnLbl && uneBtnLbl) {
        if (getSelectedStudyMode() === 'articlesDef') { unBtnLbl.textContent = i18n[curLang].btn_prefix_le || 'Prefix: le'; uneBtnLbl.textContent = i18n[curLang].btn_prefix_la || 'Prefix: la'; }
        else { unBtnLbl.textContent = i18n[curLang].btn_prefix_un; uneBtnLbl.textContent = i18n[curLang].btn_prefix_une; }
      }
      updateProgressBar();
      try { localStorage.setItem('studyMode', studyModeSelect.value); } catch (_) {}
    });

    // --- INITIALIZATION ---
    document.addEventListener('DOMContentLoaded', () => {
        // Restore preferences
        try {
          const savedVoice = localStorage.getItem('selectedVoice');
          if (savedVoice) currentVoice = savedVoice;
        } catch (_) {}
        try {
          const savedMode = localStorage.getItem('studyMode');
          const validModes = new Set(['listenRead','readThenSay','listenThenRepeat','articlesDef','articlesIndef']);
          const fallback = 'listenThenRepeat';
          const modeToUse = validModes.has(savedMode) ? savedMode : fallback;
          const sel = document.getElementById('studyModeSelect');
          if (sel) sel.value = modeToUse;
        } catch (_) {}

        populateVoiceList(); // Use the (restored) currentVoice where possible
        setLanguage("en");
        updateAllIndicators();
        welcomeModal.classList.add('visible');
        // Initialize voice debug if enabled
        renderVoiceDebug();
        // Apply iOS-only layout tweaks
        if (isIOS) { document.body.classList.add('is-ios'); document.documentElement.classList.add('is-ios'); }
        // Adjust welcome area text for iOS
        if (isIOS) {
          const dd = document.querySelector('#welcomeUploadArea h3');
          const orP = document.querySelector('#welcomeUploadArea p');
          const browseBtn = document.getElementById('welcomeBrowseBtn');
          if (dd) dd.textContent = 'Select .txt files';
          if (orP) orP.style.display = 'none';
          if (browseBtn) browseBtn.style.display = 'none';
        }
        // Initialize articles controls visibility on load
        document.getElementById('privativeControls').style.display = (getSelectedStudyMode() === 'articlesIndef' || getSelectedStudyMode() === 'articlesDef') ? 'flex' : 'none';
        // Show iOS-specific voice hint
        try {
          const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (/Macintosh/.test(navigator.userAgent) && 'ontouchend' in document);
          const hint = document.getElementById('iosVoiceHint');
          if (hint && isIOS) hint.style.display = 'block';
        } catch (_) {}
        
        // Version labels
        // Set version displays
        const verCorner = document.getElementById('appVersionCorner');
        const verWelcome = document.getElementById('welcomeVersion');
        const verMenu = document.getElementById('menuVersion');
        const verBottom = document.getElementById('bottomVersion');
        if (verCorner) verCorner.textContent = APP_VERSION;
        if (verWelcome) verWelcome.textContent = APP_VERSION;
        if (verMenu) verMenu.textContent = APP_VERSION;
        if (verBottom) verBottom.textContent = APP_VERSION;

        // Inline handlers are used for control buttons and language flags

        // Register Service Worker for PWA (https/localhost only)
        try {
          const isLocal = ['localhost','127.0.0.1'].includes(location.hostname);
          const isSecure = location.protocol === 'https:' || isLocal;
          if ('serviceWorker' in navigator && isSecure) {
            const SW_CODE = `const CACHE='study-app-v1';const CORE=['./','./index.html'];self.addEventListener('install',e=>{e.waitUntil(caches.open(CACHE).then(c=>c.addAll(CORE)).then(()=>self.skipWaiting()))});self.addEventListener('activate',e=>{e.waitUntil(caches.keys().then(keys=>Promise.all(keys.map(k=>k===CACHE?null:caches.delete(k)))).then(()=>self.clients.claim()))});self.addEventListener('fetch',e=>{const r=e.request;if(r.method!=='GET'||!r.url.startsWith(self.location.origin))return;e.respondWith(caches.match(r).then(c=>c||fetch(r).then(resp=>{const cp=resp.clone();caches.open(CACHE).then(cc=>cc.put(r,cp));return resp}).catch(()=>c)))})`;
            const swBlob = new Blob([SW_CODE], { type: 'application/javascript' });
            const swUrl = URL.createObjectURL(swBlob);
            navigator.serviceWorker.register(swUrl);
          }
        } catch (_) {}

        // Inject manifest from inline JSON (with data-URI icons)
        try {
          function makeFlagPng(size, circular){
            const c=document.createElement('canvas'); c.width=size; c.height=size; const ctx=c.getContext('2d');
            if(circular){ ctx.save(); ctx.beginPath(); ctx.arc(size/2,size/2,size/2,0,Math.PI*2); ctx.closePath(); ctx.clip(); }
            ctx.fillStyle='#0055A4'; ctx.fillRect(0,0,size/3,size);
            ctx.fillStyle='#FFFFFF'; ctx.fillRect(size/3,0,size/3,size);
            ctx.fillStyle='#EF4135'; ctx.fillRect(2*size/3,0,size/3,size);
            if(circular){ ctx.restore(); }
            return c.toDataURL('image/png');
          }
          const icon180 = makeFlagPng(180,true);
          const icon192 = makeFlagPng(192,true);
          const icon512 = makeFlagPng(512,true);
          // Set apple touch icon to PNG (iOS requires PNG)
          const apple = document.getElementById('appleIcon'); if (apple) apple.setAttribute('href', icon180);
          // Build manifest with PNG icons
          const manifestJson = {
            name: 'French Study', short_name: 'Study', start_url: './?source=pwa', display: 'standalone',
            background_color: '#F7F7F7', theme_color: '#4A90E2',
            icons: [ { src: icon192, sizes: '192x192', type: 'image/png' }, { src: icon512, sizes: '512x512', type: 'image/png' } ]
          };
          const manifestBlob = new Blob([JSON.stringify(manifestJson)], { type: 'application/manifest+json' });
          const manifestUrl = URL.createObjectURL(manifestBlob);
          const link = document.getElementById('manifestLink'); if (link) link.setAttribute('href', manifestUrl);
        } catch (_) {}

        // Standalone detection for safe-area padding
        try {
          const standalone = window.navigator.standalone || window.matchMedia('(display-mode: standalone)').matches;
          if (standalone) { document.documentElement.classList.add('is-standalone'); document.body.classList.add('is-standalone'); }
        } catch (_) {}

        // Settings: reset app button (with confirmation)
        try {
          const bindReset = (btn) => {
            if (!btn) return;
            btn.addEventListener('click', async () => {
              confirmationCallback = async () => {
                try {
                  if ('serviceWorker' in navigator) {
                    const regs = await navigator.serviceWorker.getRegistrations();
                    await Promise.all(regs.map(r => r.unregister()));
                    const keys = await caches.keys();
                    await Promise.all(keys.map(k => caches.delete(k)));
                  }
                  localStorage.clear();
                  sessionStorage.clear();
                } catch (_) {}
                location.reload();
              };
              const ctext = document.getElementById('confirmationDialogText');
              if (ctext) ctext.textContent = i18n[curLang].confirm_reset || 'This will reset the app. Continue?';
              confirmationDialog.classList.add('visible');
            });
          };
          bindReset(document.getElementById('resetAppBtn'));      // Settings modal
          bindReset(document.getElementById('menuResetAppBtn'));  // Menu panel
        } catch (_) {}
    });
  </script>
</body>
</html>
